// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/cloud/security/privateca/v1/resources.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Security.PrivateCA.V1 {

  /// <summary>Holder for reflection information generated from google/cloud/security/privateca/v1/resources.proto</summary>
  public static partial class ResourcesReflection {

    #region Descriptor
    /// <summary>File descriptor for google/cloud/security/privateca/v1/resources.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ResourcesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjJnb29nbGUvY2xvdWQvc2VjdXJpdHkvcHJpdmF0ZWNhL3YxL3Jlc291cmNl",
            "cy5wcm90bxIiZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MRof",
            "Z29vZ2xlL2FwaS9maWVsZF9iZWhhdmlvci5wcm90bxoZZ29vZ2xlL2FwaS9y",
            "ZXNvdXJjZS5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3Rv",
            "Gh9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvGhZnb29nbGUvdHlw",
            "ZS9leHByLnByb3RvGhxnb29nbGUvYXBpL2Fubm90YXRpb25zLnByb3RvIvIP",
            "ChRDZXJ0aWZpY2F0ZUF1dGhvcml0eRIRCgRuYW1lGAEgASgJQgPgQQMSUwoE",
            "dHlwZRgCIAEoDjI9Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2Eu",
            "djEuQ2VydGlmaWNhdGVBdXRob3JpdHkuVHlwZUIG4EEC4EEFEk0KBmNvbmZp",
            "ZxgDIAEoCzI1Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjEu",
            "Q2VydGlmaWNhdGVDb25maWdCBuBBAuBBBRIwCghsaWZldGltZRgEIAEoCzIZ",
            "Lmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkID4EECEmEKCGtleV9zcGVjGAUg",
            "ASgLMkcuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5DZXJ0",
            "aWZpY2F0ZUF1dGhvcml0eS5LZXlWZXJzaW9uU3BlY0IG4EEC4EEFElYKEnN1",
            "Ym9yZGluYXRlX2NvbmZpZxgGIAEoCzI1Lmdvb2dsZS5jbG91ZC5zZWN1cml0",
            "eS5wcml2YXRlY2EudjEuU3Vib3JkaW5hdGVDb25maWdCA+BBARJCCgR0aWVy",
            "GAcgASgOMi8uZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5D",
            "YVBvb2wuVGllckID4EEDElIKBXN0YXRlGAggASgOMj4uZ29vZ2xlLmNsb3Vk",
            "LnNlY3VyaXR5LnByaXZhdGVjYS52MS5DZXJ0aWZpY2F0ZUF1dGhvcml0eS5T",
            "dGF0ZUID4EEDEiAKE3BlbV9jYV9jZXJ0aWZpY2F0ZXMYCSADKAlCA+BBAxJk",
            "ChtjYV9jZXJ0aWZpY2F0ZV9kZXNjcmlwdGlvbnMYCiADKAsyOi5nb29nbGUu",
            "Y2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxLkNlcnRpZmljYXRlRGVzY3Jp",
            "cHRpb25CA+BBAxIXCgpnY3NfYnVja2V0GAsgASgJQgPgQQUSXQoLYWNjZXNz",
            "X3VybHMYDCABKAsyQy5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNh",
            "LnYxLkNlcnRpZmljYXRlQXV0aG9yaXR5LkFjY2Vzc1VybHNCA+BBAxI0Cgtj",
            "cmVhdGVfdGltZRgNIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBC",
            "A+BBAxI0Cgt1cGRhdGVfdGltZRgOIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5U",
            "aW1lc3RhbXBCA+BBAxI0CgtkZWxldGVfdGltZRgPIAEoCzIaLmdvb2dsZS5w",
            "cm90b2J1Zi5UaW1lc3RhbXBCA+BBAxI0CgtleHBpcmVfdGltZRgQIAEoCzIa",
            "Lmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAxJZCgZsYWJlbHMYESAD",
            "KAsyRC5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxLkNlcnRp",
            "ZmljYXRlQXV0aG9yaXR5LkxhYmVsc0VudHJ5QgPgQQEaSAoKQWNjZXNzVXJs",
            "cxIhChljYV9jZXJ0aWZpY2F0ZV9hY2Nlc3NfdXJsGAEgASgJEhcKD2NybF9h",
            "Y2Nlc3NfdXJscxgCIAMoCRqgAQoOS2V5VmVyc2lvblNwZWMSHwoVY2xvdWRf",
            "a21zX2tleV92ZXJzaW9uGAEgASgJSAASXwoJYWxnb3JpdGhtGAIgASgOMkou",
            "Z29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5DZXJ0aWZpY2F0",
            "ZUF1dGhvcml0eS5TaWduSGFzaEFsZ29yaXRobUgAQgwKCktleVZlcnNpb24a",
            "LQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4",
            "ASI+CgRUeXBlEhQKEFRZUEVfVU5TUEVDSUZJRUQQABIPCgtTRUxGX1NJR05F",
            "RBABEg8KC1NVQk9SRElOQVRFEAIicAoFU3RhdGUSFQoRU1RBVEVfVU5TUEVD",
            "SUZJRUQQABILCgdFTkFCTEVEEAESDAoIRElTQUJMRUQQAhIKCgZTVEFHRUQQ",
            "AxIcChhBV0FJVElOR19VU0VSX0FDVElWQVRJT04QBBILCgdERUxFVEVEEAUi",
            "/AEKEVNpZ25IYXNoQWxnb3JpdGhtEiMKH1NJR05fSEFTSF9BTEdPUklUSE1f",
            "VU5TUEVDSUZJRUQQABIXChNSU0FfUFNTXzIwNDhfU0hBMjU2EAESFwoTUlNB",
            "X1BTU18zMDcyX1NIQTI1NhACEhcKE1JTQV9QU1NfNDA5Nl9TSEEyNTYQAxIZ",
            "ChVSU0FfUEtDUzFfMjA0OF9TSEEyNTYQBhIZChVSU0FfUEtDUzFfMzA3Ml9T",
            "SEEyNTYQBxIZChVSU0FfUEtDUzFfNDA5Nl9TSEEyNTYQCBISCg5FQ19QMjU2",
            "X1NIQTI1NhAEEhIKDkVDX1AzODRfU0hBMzg0EAU6nQHqQZkBCi1wcml2YXRl",
            "Y2EuZ29vZ2xlYXBpcy5jb20vQ2VydGlmaWNhdGVBdXRob3JpdHkSaHByb2pl",
            "Y3RzL3twcm9qZWN0fS9sb2NhdGlvbnMve2xvY2F0aW9ufS9jYVBvb2xzL3tj",
            "YV9wb29sfS9jZXJ0aWZpY2F0ZUF1dGhvcml0aWVzL3tjZXJ0aWZpY2F0ZV9h",
            "dXRob3JpdHl9IvAOCgZDYVBvb2wSEQoEbmFtZRgBIAEoCUID4EEDEkUKBHRp",
            "ZXIYAiABKA4yLy5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYx",
            "LkNhUG9vbC5UaWVyQgbgQQLgQQUSVwoPaXNzdWFuY2VfcG9saWN5GAMgASgL",
            "MjkuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5DYVBvb2wu",
            "SXNzdWFuY2VQb2xpY3lCA+BBARJdChJwdWJsaXNoaW5nX29wdGlvbnMYBCAB",
            "KAsyPC5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxLkNhUG9v",
            "bC5QdWJsaXNoaW5nT3B0aW9uc0ID4EEBEksKBmxhYmVscxgFIAMoCzI2Lmdv",
            "b2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjEuQ2FQb29sLkxhYmVs",
            "c0VudHJ5QgPgQQEaSwoRUHVibGlzaGluZ09wdGlvbnMSHAoPcHVibGlzaF9j",
            "YV9jZXJ0GAEgASgIQgPgQQISGAoLcHVibGlzaF9jcmwYAiABKAhCA+BBAhrv",
            "CQoOSXNzdWFuY2VQb2xpY3kSaAoRYWxsb3dlZF9rZXlfdHlwZXMYASADKAsy",
            "SC5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxLkNhUG9vbC5J",
            "c3N1YW5jZVBvbGljeS5BbGxvd2VkS2V5VHlwZUID4EEBEjgKEG1heGltdW1f",
            "bGlmZXRpbWUYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BB",
            "ARJsChZhbGxvd2VkX2lzc3VhbmNlX21vZGVzGAMgASgLMkcuZ29vZ2xlLmNs",
            "b3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5DYVBvb2wuSXNzdWFuY2VQb2xp",
            "Y3kuSXNzdWFuY2VNb2Rlc0ID4EEBElAKD2Jhc2VsaW5lX3ZhbHVlcxgEIAEo",
            "CzIyLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjEuWDUwOVBh",
            "cmFtZXRlcnNCA+BBARJlChRpZGVudGl0eV9jb25zdHJhaW50cxgFIAEoCzJC",
            "Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjEuQ2VydGlmaWNh",
            "dGVJZGVudGl0eUNvbnN0cmFpbnRzQgPgQQESaAoWcGFzc3Rocm91Z2hfZXh0",
            "ZW5zaW9ucxgGIAEoCzJDLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRl",
            "Y2EudjEuQ2VydGlmaWNhdGVFeHRlbnNpb25Db25zdHJhaW50c0ID4EEBGsUE",
            "Cg5BbGxvd2VkS2V5VHlwZRJiCgNyc2EYASABKAsyUy5nb29nbGUuY2xvdWQu",
            "c2VjdXJpdHkucHJpdmF0ZWNhLnYxLkNhUG9vbC5Jc3N1YW5jZVBvbGljeS5B",
            "bGxvd2VkS2V5VHlwZS5Sc2FLZXlUeXBlSAASbAoOZWxsaXB0aWNfY3VydmUY",
            "AiABKAsyUi5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxLkNh",
            "UG9vbC5Jc3N1YW5jZVBvbGljeS5BbGxvd2VkS2V5VHlwZS5FY0tleVR5cGVI",
            "ABpKCgpSc2FLZXlUeXBlEh0KEG1pbl9tb2R1bHVzX3NpemUYASABKANCA+BB",
            "ARIdChBtYXhfbW9kdWx1c19zaXplGAIgASgDQgPgQQEaiAIKCUVjS2V5VHlw",
            "ZRKJAQoTc2lnbmF0dXJlX2FsZ29yaXRobRgBIAEoDjJnLmdvb2dsZS5jbG91",
            "ZC5zZWN1cml0eS5wcml2YXRlY2EudjEuQ2FQb29sLklzc3VhbmNlUG9saWN5",
            "LkFsbG93ZWRLZXlUeXBlLkVjS2V5VHlwZS5FY1NpZ25hdHVyZUFsZ29yaXRo",
            "bUID4EEBIm8KFEVjU2lnbmF0dXJlQWxnb3JpdGhtEiYKIkVDX1NJR05BVFVS",
            "RV9BTEdPUklUSE1fVU5TUEVDSUZJRUQQABIOCgpFQ0RTQV9QMjU2EAESDgoK",
            "RUNEU0FfUDM4NBACEg8KC0VERFNBXzI1NTE5EANCCgoIa2V5X3R5cGUaYAoN",
            "SXNzdWFuY2VNb2RlcxIlChhhbGxvd19jc3JfYmFzZWRfaXNzdWFuY2UYASAB",
            "KAhCA+BBAhIoChthbGxvd19jb25maWdfYmFzZWRfaXNzdWFuY2UYAiABKAhC",
            "A+BBAhotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiAB",
            "KAk6AjgBIjgKBFRpZXISFAoQVElFUl9VTlNQRUNJRklFRBAAEg4KCkVOVEVS",
            "UFJJU0UQARIKCgZERVZPUFMQAjpf6kFcCh9wcml2YXRlY2EuZ29vZ2xlYXBp",
            "cy5jb20vQ2FQb29sEjlwcm9qZWN0cy97cHJvamVjdH0vbG9jYXRpb25zL3ts",
            "b2NhdGlvbn0vY2FQb29scy97Y2FfcG9vbH0ivAgKGUNlcnRpZmljYXRlUmV2",
            "b2NhdGlvbkxpc3QSEQoEbmFtZRgBIAEoCUID4EEDEhwKD3NlcXVlbmNlX251",
            "bWJlchgCIAEoA0ID4EEDEnMKFHJldm9rZWRfY2VydGlmaWNhdGVzGAMgAygL",
            "MlAuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5DZXJ0aWZp",
            "Y2F0ZVJldm9jYXRpb25MaXN0LlJldm9rZWRDZXJ0aWZpY2F0ZUID4EEDEhQK",
            "B3BlbV9jcmwYBCABKAlCA+BBAxIXCgphY2Nlc3NfdXJsGAUgASgJQgPgQQMS",
            "VwoFc3RhdGUYBiABKA4yQy5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0",
            "ZWNhLnYxLkNlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3QuU3RhdGVCA+BBAxI0",
            "CgtjcmVhdGVfdGltZRgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3Rh",
            "bXBCA+BBAxI0Cgt1cGRhdGVfdGltZRgIIAEoCzIaLmdvb2dsZS5wcm90b2J1",
            "Zi5UaW1lc3RhbXBCA+BBAxIYCgtyZXZpc2lvbl9pZBgJIAEoCUID4EEDEl4K",
            "BmxhYmVscxgKIAMoCzJJLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRl",
            "Y2EudjEuQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdC5MYWJlbHNFbnRyeUID",
            "4EEBGsABChJSZXZva2VkQ2VydGlmaWNhdGUSPgoLY2VydGlmaWNhdGUYASAB",
            "KAlCKfpBJgokcHJpdmF0ZWNhLmdvb2dsZWFwaXMuY29tL0NlcnRpZmljYXRl",
            "EhkKEWhleF9zZXJpYWxfbnVtYmVyGAIgASgJEk8KEXJldm9jYXRpb25fcmVh",
            "c29uGAMgASgOMjQuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52",
            "MS5SZXZvY2F0aW9uUmVhc29uGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEo",
            "CRINCgV2YWx1ZRgCIAEoCToCOAEiOgoFU3RhdGUSFQoRU1RBVEVfVU5TUEVD",
            "SUZJRUQQABIKCgZBQ1RJVkUQARIOCgpTVVBFUlNFREVEEAI63AHqQdgBCjJw",
            "cml2YXRlY2EuZ29vZ2xlYXBpcy5jb20vQ2VydGlmaWNhdGVSZXZvY2F0aW9u",
            "TGlzdBKhAXByb2plY3RzL3twcm9qZWN0fS9sb2NhdGlvbnMve2xvY2F0aW9u",
            "fS9jYVBvb2xzL3tjYV9wb29sfS9jZXJ0aWZpY2F0ZUF1dGhvcml0aWVzL3tj",
            "ZXJ0aWZpY2F0ZV9hdXRob3JpdHl9L2NlcnRpZmljYXRlUmV2b2NhdGlvbkxp",
            "c3RzL3tjZXJ0aWZpY2F0ZV9yZXZvY2F0aW9uX2xpc3R9Io8KCgtDZXJ0aWZp",
            "Y2F0ZRI6CgRuYW1lGAEgASgJQizgQQP6QSYKJHByaXZhdGVjYS5nb29nbGVh",
            "cGlzLmNvbS9DZXJ0aWZpY2F0ZRIWCgdwZW1fY3NyGAIgASgJQgPgQQVIABJM",
            "CgZjb25maWcYAyABKAsyNS5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0",
            "ZWNhLnYxLkNlcnRpZmljYXRlQ29uZmlnQgPgQQVIABJbChxpc3N1ZXJfY2Vy",
            "dGlmaWNhdGVfYXV0aG9yaXR5GAQgASgJQjXgQQP6QS8KLXByaXZhdGVjYS5n",
            "b29nbGVhcGlzLmNvbS9DZXJ0aWZpY2F0ZUF1dGhvcml0eRIzCghsaWZldGlt",
            "ZRgFIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIG4EEC4EEFElIK",
            "FGNlcnRpZmljYXRlX3RlbXBsYXRlGAYgASgJQjTgQQX6QS4KLHByaXZhdGVj",
            "YS5nb29nbGVhcGlzLmNvbS9DZXJ0aWZpY2F0ZVRlbXBsYXRlElEKDHN1Ympl",
            "Y3RfbW9kZRgHIAEoDjI2Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRl",
            "Y2EudjEuU3ViamVjdFJlcXVlc3RNb2RlQgPgQQUSYgoScmV2b2NhdGlvbl9k",
            "ZXRhaWxzGAggASgLMkEuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVj",
            "YS52MS5DZXJ0aWZpY2F0ZS5SZXZvY2F0aW9uRGV0YWlsc0ID4EEDEhwKD3Bl",
            "bV9jZXJ0aWZpY2F0ZRgJIAEoCUID4EEDEmAKF2NlcnRpZmljYXRlX2Rlc2Ny",
            "aXB0aW9uGAogASgLMjouZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVj",
            "YS52MS5DZXJ0aWZpY2F0ZURlc2NyaXB0aW9uQgPgQQMSIgoVcGVtX2NlcnRp",
            "ZmljYXRlX2NoYWluGAsgAygJQgPgQQMSNAoLY3JlYXRlX3RpbWUYDCABKAsy",
            "Gi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPgQQMSNAoLdXBkYXRlX3Rp",
            "bWUYDSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPgQQMSUAoG",
            "bGFiZWxzGA4gAygLMjsuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVj",
            "YS52MS5DZXJ0aWZpY2F0ZS5MYWJlbHNFbnRyeUID4EEBGpgBChFSZXZvY2F0",
            "aW9uRGV0YWlscxJOChByZXZvY2F0aW9uX3N0YXRlGAEgASgOMjQuZ29vZ2xl",
            "LmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5SZXZvY2F0aW9uUmVhc29u",
            "EjMKD3Jldm9jYXRpb25fdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5U",
            "aW1lc3RhbXAaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVl",
            "GAIgASgJOgI4ATp/6kF8CiRwcml2YXRlY2EuZ29vZ2xlYXBpcy5jb20vQ2Vy",
            "dGlmaWNhdGUSVHByb2plY3RzL3twcm9qZWN0fS9sb2NhdGlvbnMve2xvY2F0",
            "aW9ufS9jYVBvb2xzL3tjYV9wb29sfS9jZXJ0aWZpY2F0ZXMve2NlcnRpZmlj",
            "YXRlfUIUChJjZXJ0aWZpY2F0ZV9jb25maWcilwYKE0NlcnRpZmljYXRlVGVt",
            "cGxhdGUSQgoEbmFtZRgBIAEoCUI04EED+kEuCixwcml2YXRlY2EuZ29vZ2xl",
            "YXBpcy5jb20vQ2VydGlmaWNhdGVUZW1wbGF0ZRJSChFwcmVkZWZpbmVkX3Zh",
            "bHVlcxgCIAEoCzIyLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2Eu",
            "djEuWDUwOVBhcmFtZXRlcnNCA+BBARJlChRpZGVudGl0eV9jb25zdHJhaW50",
            "cxgDIAEoCzJCLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjEu",
            "Q2VydGlmaWNhdGVJZGVudGl0eUNvbnN0cmFpbnRzQgPgQQESaAoWcGFzc3Ro",
            "cm91Z2hfZXh0ZW5zaW9ucxgEIAEoCzJDLmdvb2dsZS5jbG91ZC5zZWN1cml0",
            "eS5wcml2YXRlY2EudjEuQ2VydGlmaWNhdGVFeHRlbnNpb25Db25zdHJhaW50",
            "c0ID4EEBEhgKC2Rlc2NyaXB0aW9uGAUgASgJQgPgQQESNAoLY3JlYXRlX3Rp",
            "bWUYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPgQQMSNAoL",
            "dXBkYXRlX3RpbWUYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1w",
            "QgPgQQMSWAoGbGFiZWxzGAggAygLMkMuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5",
            "LnByaXZhdGVjYS52MS5DZXJ0aWZpY2F0ZVRlbXBsYXRlLkxhYmVsc0VudHJ5",
            "QgPgQQEaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIg",
            "ASgJOgI4ATqHAepBgwEKLHByaXZhdGVjYS5nb29nbGVhcGlzLmNvbS9DZXJ0",
            "aWZpY2F0ZVRlbXBsYXRlElNwcm9qZWN0cy97cHJvamVjdH0vbG9jYXRpb25z",
            "L3tsb2NhdGlvbn0vY2VydGlmaWNhdGVUZW1wbGF0ZXMve2NlcnRpZmljYXRl",
            "X3RlbXBsYXRlfSLfAwoOWDUwOVBhcmFtZXRlcnMSRAoJa2V5X3VzYWdlGAEg",
            "ASgLMiwuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5LZXlV",
            "c2FnZUID4EEBElUKCmNhX29wdGlvbnMYAiABKAsyPC5nb29nbGUuY2xvdWQu",
            "c2VjdXJpdHkucHJpdmF0ZWNhLnYxLlg1MDlQYXJhbWV0ZXJzLkNhT3B0aW9u",
            "c0ID4EEBEkUKCnBvbGljeV9pZHMYAyADKAsyLC5nb29nbGUuY2xvdWQuc2Vj",
            "dXJpdHkucHJpdmF0ZWNhLnYxLk9iamVjdElkQgPgQQESHQoQYWlhX29jc3Bf",
            "c2VydmVycxgEIAMoCUID4EEBElUKFWFkZGl0aW9uYWxfZXh0ZW5zaW9ucxgF",
            "IAMoCzIxLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjEuWDUw",
            "OUV4dGVuc2lvbkID4EEBGnMKCUNhT3B0aW9ucxIXCgVpc19jYRgBIAEoCEID",
            "4EEBSACIAQESKAoWbWF4X2lzc3Vlcl9wYXRoX2xlbmd0aBgCIAEoBUID4EEB",
            "SAGIAQFCCAoGX2lzX2NhQhkKF19tYXhfaXNzdWVyX3BhdGhfbGVuZ3RoIqkC",
            "ChFTdWJvcmRpbmF0ZUNvbmZpZxJWChVjZXJ0aWZpY2F0ZV9hdXRob3JpdHkY",
            "ASABKAlCNeBBAvpBLwotcHJpdmF0ZWNhLmdvb2dsZWFwaXMuY29tL0NlcnRp",
            "ZmljYXRlQXV0aG9yaXR5SAASbQoQcGVtX2lzc3Vlcl9jaGFpbhgCIAEoCzJM",
            "Lmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjEuU3Vib3JkaW5h",
            "dGVDb25maWcuU3Vib3JkaW5hdGVDb25maWdDaGFpbkID4EECSAAaNwoWU3Vi",
            "b3JkaW5hdGVDb25maWdDaGFpbhIdChBwZW1fY2VydGlmaWNhdGVzGAEgAygJ",
            "QgPgQQJCFAoSc3Vib3JkaW5hdGVfY29uZmlnIp0BCglQdWJsaWNLZXkSEAoD",
            "a2V5GAEgASgMQgPgQQISTAoGZm9ybWF0GAIgASgOMjcuZ29vZ2xlLmNsb3Vk",
            "LnNlY3VyaXR5LnByaXZhdGVjYS52MS5QdWJsaWNLZXkuS2V5Rm9ybWF0QgPg",
            "QQIiMAoJS2V5Rm9ybWF0EhoKFktFWV9GT1JNQVRfVU5TUEVDSUZJRUQQABIH",
            "CgNQRU0QASK0AwoRQ2VydGlmaWNhdGVDb25maWcSYAoOc3ViamVjdF9jb25m",
            "aWcYASABKAsyQy5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYx",
            "LkNlcnRpZmljYXRlQ29uZmlnLlN1YmplY3RDb25maWdCA+BBAhJMCgt4NTA5",
            "X2NvbmZpZxgCIAEoCzIyLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRl",
            "Y2EudjEuWDUwOVBhcmFtZXRlcnNCA+BBAhJGCgpwdWJsaWNfa2V5GAMgASgL",
            "Mi0uZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5QdWJsaWNL",
            "ZXlCA+BBARqmAQoNU3ViamVjdENvbmZpZxJBCgdzdWJqZWN0GAEgASgLMisu",
            "Z29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5TdWJqZWN0QgPg",
            "QQISUgoQc3ViamVjdF9hbHRfbmFtZRgCIAEoCzIzLmdvb2dsZS5jbG91ZC5z",
            "ZWN1cml0eS5wcml2YXRlY2EudjEuU3ViamVjdEFsdE5hbWVzQgPgQQEioQgK",
            "FkNlcnRpZmljYXRlRGVzY3JpcHRpb24SagoTc3ViamVjdF9kZXNjcmlwdGlv",
            "bhgBIAEoCzJNLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjEu",
            "Q2VydGlmaWNhdGVEZXNjcmlwdGlvbi5TdWJqZWN0RGVzY3JpcHRpb24STAoQ",
            "eDUwOV9kZXNjcmlwdGlvbhgCIAEoCzIyLmdvb2dsZS5jbG91ZC5zZWN1cml0",
            "eS5wcml2YXRlY2EudjEuWDUwOVBhcmFtZXRlcnMSQQoKcHVibGljX2tleRgD",
            "IAEoCzItLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2EudjEuUHVi",
            "bGljS2V5ElgKDnN1YmplY3Rfa2V5X2lkGAQgASgLMkAuZ29vZ2xlLmNsb3Vk",
            "LnNlY3VyaXR5LnByaXZhdGVjYS52MS5DZXJ0aWZpY2F0ZURlc2NyaXB0aW9u",
            "LktleUlkEloKEGF1dGhvcml0eV9rZXlfaWQYBSABKAsyQC5nb29nbGUuY2xv",
            "dWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxLkNlcnRpZmljYXRlRGVzY3JpcHRp",
            "b24uS2V5SWQSHwoXY3JsX2Rpc3RyaWJ1dGlvbl9wb2ludHMYBiADKAkSJAoc",
            "YWlhX2lzc3VpbmdfY2VydGlmaWNhdGVfdXJscxgHIAMoCRJrChBjZXJ0X2Zp",
            "bmdlcnByaW50GAggASgLMlEuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZh",
            "dGVjYS52MS5DZXJ0aWZpY2F0ZURlc2NyaXB0aW9uLkNlcnRpZmljYXRlRmlu",
            "Z2VycHJpbnQa0gIKElN1YmplY3REZXNjcmlwdGlvbhI8CgdzdWJqZWN0GAEg",
            "ASgLMisuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52MS5TdWJq",
            "ZWN0Ek0KEHN1YmplY3RfYWx0X25hbWUYAiABKAsyMy5nb29nbGUuY2xvdWQu",
            "c2VjdXJpdHkucHJpdmF0ZWNhLnYxLlN1YmplY3RBbHROYW1lcxIZChFoZXhf",
            "c2VyaWFsX251bWJlchgDIAEoCRIrCghsaWZldGltZRgEIAEoCzIZLmdvb2ds",
            "ZS5wcm90b2J1Zi5EdXJhdGlvbhIzCg9ub3RfYmVmb3JlX3RpbWUYBSABKAsy",
            "Gi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjIKDm5vdF9hZnRlcl90aW1l",
            "GAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBocCgVLZXlJZBIT",
            "CgZrZXlfaWQYASABKAlCA+BBARotChZDZXJ0aWZpY2F0ZUZpbmdlcnByaW50",
            "EhMKC3NoYTI1Nl9oYXNoGAEgASgJIicKCE9iamVjdElkEhsKDm9iamVjdF9p",
            "ZF9wYXRoGAEgAygFQgPgQQIigAEKDVg1MDlFeHRlbnNpb24SRAoJb2JqZWN0",
            "X2lkGAEgASgLMiwuZ29vZ2xlLmNsb3VkLnNlY3VyaXR5LnByaXZhdGVjYS52",
            "MS5PYmplY3RJZEID4EECEhUKCGNyaXRpY2FsGAIgASgIQgPgQQISEgoFdmFs",
            "dWUYAyABKAxCA+BBAiKiBQoIS2V5VXNhZ2USVAoOYmFzZV9rZXlfdXNhZ2UY",
            "ASABKAsyPC5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxLktl",
            "eVVzYWdlLktleVVzYWdlT3B0aW9ucxJgChJleHRlbmRlZF9rZXlfdXNhZ2UY",
            "AiABKAsyRC5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYxLktl",
            "eVVzYWdlLkV4dGVuZGVkS2V5VXNhZ2VPcHRpb25zElEKG3Vua25vd25fZXh0",
            "ZW5kZWRfa2V5X3VzYWdlcxgDIAMoCzIsLmdvb2dsZS5jbG91ZC5zZWN1cml0",
            "eS5wcml2YXRlY2EudjEuT2JqZWN0SWQa5wEKD0tleVVzYWdlT3B0aW9ucxIZ",
            "ChFkaWdpdGFsX3NpZ25hdHVyZRgBIAEoCBIaChJjb250ZW50X2NvbW1pdG1l",
            "bnQYAiABKAgSGAoQa2V5X2VuY2lwaGVybWVudBgDIAEoCBIZChFkYXRhX2Vu",
            "Y2lwaGVybWVudBgEIAEoCBIVCg1rZXlfYWdyZWVtZW50GAUgASgIEhEKCWNl",
            "cnRfc2lnbhgGIAEoCBIQCghjcmxfc2lnbhgHIAEoCBIVCg1lbmNpcGhlcl9v",
            "bmx5GAggASgIEhUKDWRlY2lwaGVyX29ubHkYCSABKAgaoAEKF0V4dGVuZGVk",
            "S2V5VXNhZ2VPcHRpb25zEhMKC3NlcnZlcl9hdXRoGAEgASgIEhMKC2NsaWVu",
            "dF9hdXRoGAIgASgIEhQKDGNvZGVfc2lnbmluZxgDIAEoCBIYChBlbWFpbF9w",
            "cm90ZWN0aW9uGAQgASgIEhUKDXRpbWVfc3RhbXBpbmcYBSABKAgSFAoMb2Nz",
            "cF9zaWduaW5nGAYgASgIIrgBCgdTdWJqZWN0EhMKC2NvbW1vbl9uYW1lGAEg",
            "ASgJEhQKDGNvdW50cnlfY29kZRgCIAEoCRIUCgxvcmdhbml6YXRpb24YAyAB",
            "KAkSGwoTb3JnYW5pemF0aW9uYWxfdW5pdBgEIAEoCRIQCghsb2NhbGl0eRgF",
            "IAEoCRIQCghwcm92aW5jZRgGIAEoCRIWCg5zdHJlZXRfYWRkcmVzcxgHIAEo",
            "CRITCgtwb3N0YWxfY29kZRgIIAEoCSKpAQoPU3ViamVjdEFsdE5hbWVzEhEK",
            "CWRuc19uYW1lcxgBIAMoCRIMCgR1cmlzGAIgAygJEhcKD2VtYWlsX2FkZHJl",
            "c3NlcxgDIAMoCRIUCgxpcF9hZGRyZXNzZXMYBCADKAkSRgoLY3VzdG9tX3Nh",
            "bnMYBSADKAsyMS5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0ZWNhLnYx",
            "Llg1MDlFeHRlbnNpb24i+gEKHkNlcnRpZmljYXRlSWRlbnRpdHlDb25zdHJh",
            "aW50cxIuCg5jZWxfZXhwcmVzc2lvbhgBIAEoCzIRLmdvb2dsZS50eXBlLkV4",
            "cHJCA+BBARIrChlhbGxvd19zdWJqZWN0X3Bhc3N0aHJvdWdoGAIgASgIQgPg",
            "QQJIAIgBARI1CiNhbGxvd19zdWJqZWN0X2FsdF9uYW1lc19wYXNzdGhyb3Vn",
            "aBgDIAEoCEID4EECSAGIAQFCHAoaX2FsbG93X3N1YmplY3RfcGFzc3Rocm91",
            "Z2hCJgokX2FsbG93X3N1YmplY3RfYWx0X25hbWVzX3Bhc3N0aHJvdWdoIp4D",
            "Ch9DZXJ0aWZpY2F0ZUV4dGVuc2lvbkNvbnN0cmFpbnRzEnwKEGtub3duX2V4",
            "dGVuc2lvbnMYASADKA4yXS5nb29nbGUuY2xvdWQuc2VjdXJpdHkucHJpdmF0",
            "ZWNhLnYxLkNlcnRpZmljYXRlRXh0ZW5zaW9uQ29uc3RyYWludHMuS25vd25D",
            "ZXJ0aWZpY2F0ZUV4dGVuc2lvbkID4EEBElAKFWFkZGl0aW9uYWxfZXh0ZW5z",
            "aW9ucxgCIAMoCzIsLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2YXRlY2Eu",
            "djEuT2JqZWN0SWRCA+BBASKqAQoZS25vd25DZXJ0aWZpY2F0ZUV4dGVuc2lv",
            "bhIrCidLTk9XTl9DRVJUSUZJQ0FURV9FWFRFTlNJT05fVU5TUEVDSUZJRUQQ",
            "ABISCg5CQVNFX0tFWV9VU0FHRRABEhYKEkVYVEVOREVEX0tFWV9VU0FHRRAC",
            "Eg4KCkNBX09QVElPTlMQAxIOCgpQT0xJQ1lfSURTEAQSFAoQQUlBX09DU1Bf",
            "U0VSVkVSUxAFKocCChBSZXZvY2F0aW9uUmVhc29uEiEKHVJFVk9DQVRJT05f",
            "UkVBU09OX1VOU1BFQ0lGSUVEEAASEgoOS0VZX0NPTVBST01JU0UQARIkCiBD",
            "RVJUSUZJQ0FURV9BVVRIT1JJVFlfQ09NUFJPTUlTRRACEhcKE0FGRklMSUFU",
            "SU9OX0NIQU5HRUQQAxIOCgpTVVBFUlNFREVEEAQSGgoWQ0VTU0FUSU9OX09G",
            "X09QRVJBVElPThAFEhQKEENFUlRJRklDQVRFX0hPTEQQBhIXChNQUklWSUxF",
            "R0VfV0lUSERSQVdOEAcSIgoeQVRUUklCVVRFX0FVVEhPUklUWV9DT01QUk9N",
            "SVNFEAgqXQoSU3ViamVjdFJlcXVlc3RNb2RlEiQKIFNVQkpFQ1RfUkVRVUVT",
            "VF9NT0RFX1VOU1BFQ0lGSUVEEAASCwoHREVGQVVMVBABEhQKEFJFRkxFQ1RF",
            "RF9TUElGRkUQAkKGAgomY29tLmdvb2dsZS5jbG91ZC5zZWN1cml0eS5wcml2",
            "YXRlY2EudjFCF1ByaXZhdGVDYVJlc291cmNlc1Byb3RvUAFaS2dvb2dsZS5n",
            "b2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvY2xvdWQvc2VjdXJpdHkv",
            "cHJpdmF0ZWNhL3YxO3ByaXZhdGVjYfgBAaoCIkdvb2dsZS5DbG91ZC5TZWN1",
            "cml0eS5Qcml2YXRlQ0EuVjHKAiJHb29nbGVcQ2xvdWRcU2VjdXJpdHlcUHJp",
            "dmF0ZUNBXFYx6gImR29vZ2xlOjpDbG91ZDo6U2VjdXJpdHk6OlByaXZhdGVD",
            "QTo6VjFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Type.ExprReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Cloud.Security.PrivateCA.V1.RevocationReason), typeof(global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority), global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Parser, new[]{ "Name", "Type", "Config", "Lifetime", "KeySpec", "SubordinateConfig", "Tier", "State", "PemCaCertificates", "CaCertificateDescriptions", "GcsBucket", "AccessUrls", "CreateTime", "UpdateTime", "DeleteTime", "ExpireTime", "Labels" }, null, new[]{ typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type), typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State), typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.SignHashAlgorithm) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.AccessUrls), global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.AccessUrls.Parser, new[]{ "CaCertificateAccessUrl", "CrlAccessUrls" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.KeyVersionSpec), global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.KeyVersionSpec.Parser, new[]{ "CloudKmsKeyVersion", "Algorithm" }, new[]{ "KeyVersion" }, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CaPool), global::Google.Cloud.Security.PrivateCA.V1.CaPool.Parser, new[]{ "Name", "Tier", "IssuancePolicy", "PublishingOptions", "Labels" }, null, new[]{ typeof(global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.PublishingOptions), global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.PublishingOptions.Parser, new[]{ "PublishCaCert", "PublishCrl" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy), global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Parser, new[]{ "AllowedKeyTypes", "MaximumLifetime", "AllowedIssuanceModes", "BaselineValues", "IdentityConstraints", "PassthroughExtensions" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType), global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Parser, new[]{ "Rsa", "EllipticCurve" }, new[]{ "KeyType" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.RsaKeyType), global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.RsaKeyType.Parser, new[]{ "MinModulusSize", "MaxModulusSize" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType), global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Parser, new[]{ "SignatureAlgorithm" }, null, new[]{ typeof(global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.IssuanceModes), global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.IssuanceModes.Parser, new[]{ "AllowCsrBasedIssuance", "AllowConfigBasedIssuance" }, null, null, null, null)}),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList), global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Parser, new[]{ "Name", "SequenceNumber", "RevokedCertificates", "PemCrl", "AccessUrl", "State", "CreateTime", "UpdateTime", "RevisionId", "Labels" }, null, new[]{ typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.RevokedCertificate), global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.RevokedCertificate.Parser, new[]{ "Certificate", "HexSerialNumber", "RevocationReason" }, null, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.Certificate), global::Google.Cloud.Security.PrivateCA.V1.Certificate.Parser, new[]{ "Name", "PemCsr", "Config", "IssuerCertificateAuthority", "Lifetime", "CertificateTemplate", "SubjectMode", "RevocationDetails", "PemCertificate", "CertificateDescription", "PemCertificateChain", "CreateTime", "UpdateTime", "Labels" }, new[]{ "CertificateConfig" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.Certificate.Types.RevocationDetails), global::Google.Cloud.Security.PrivateCA.V1.Certificate.Types.RevocationDetails.Parser, new[]{ "RevocationState", "RevocationTime" }, null, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateTemplate), global::Google.Cloud.Security.PrivateCA.V1.CertificateTemplate.Parser, new[]{ "Name", "PredefinedValues", "IdentityConstraints", "PassthroughExtensions", "Description", "CreateTime", "UpdateTime", "Labels" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.X509Parameters), global::Google.Cloud.Security.PrivateCA.V1.X509Parameters.Parser, new[]{ "KeyUsage", "CaOptions", "PolicyIds", "AiaOcspServers", "AdditionalExtensions" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.X509Parameters.Types.CaOptions), global::Google.Cloud.Security.PrivateCA.V1.X509Parameters.Types.CaOptions.Parser, new[]{ "IsCa", "MaxIssuerPathLength" }, new[]{ "IsCa", "MaxIssuerPathLength" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig), global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Parser, new[]{ "CertificateAuthority", "PemIssuerChain" }, new[]{ "SubordinateConfig" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Types.SubordinateConfigChain), global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Types.SubordinateConfigChain.Parser, new[]{ "PemCertificates" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.PublicKey), global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Parser, new[]{ "Key", "Format" }, null, new[]{ typeof(global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig), global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig.Parser, new[]{ "SubjectConfig", "X509Config", "PublicKey" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig.Types.SubjectConfig), global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig.Types.SubjectConfig.Parser, new[]{ "Subject", "SubjectAltName" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription), global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Parser, new[]{ "SubjectDescription", "X509Description", "PublicKey", "SubjectKeyId", "AuthorityKeyId", "CrlDistributionPoints", "AiaIssuingCertificateUrls", "CertFingerprint" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.SubjectDescription), global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.SubjectDescription.Parser, new[]{ "Subject", "SubjectAltName", "HexSerialNumber", "Lifetime", "NotBeforeTime", "NotAfterTime" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId), global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId.Parser, new[]{ "KeyId_" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.CertificateFingerprint), global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.CertificateFingerprint.Parser, new[]{ "Sha256Hash" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.ObjectId), global::Google.Cloud.Security.PrivateCA.V1.ObjectId.Parser, new[]{ "ObjectIdPath" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.X509Extension), global::Google.Cloud.Security.PrivateCA.V1.X509Extension.Parser, new[]{ "ObjectId", "Critical", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.KeyUsage), global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Parser, new[]{ "BaseKeyUsage", "ExtendedKeyUsage", "UnknownExtendedKeyUsages" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.KeyUsageOptions), global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.KeyUsageOptions.Parser, new[]{ "DigitalSignature", "ContentCommitment", "KeyEncipherment", "DataEncipherment", "KeyAgreement", "CertSign", "CrlSign", "EncipherOnly", "DecipherOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.ExtendedKeyUsageOptions), global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.ExtendedKeyUsageOptions.Parser, new[]{ "ServerAuth", "ClientAuth", "CodeSigning", "EmailProtection", "TimeStamping", "OcspSigning" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.Subject), global::Google.Cloud.Security.PrivateCA.V1.Subject.Parser, new[]{ "CommonName", "CountryCode", "Organization", "OrganizationalUnit", "Locality", "Province", "StreetAddress", "PostalCode" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames), global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames.Parser, new[]{ "DnsNames", "Uris", "EmailAddresses", "IpAddresses", "CustomSans" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints), global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints.Parser, new[]{ "CelExpression", "AllowSubjectPassthrough", "AllowSubjectAltNamesPassthrough" }, new[]{ "AllowSubjectPassthrough", "AllowSubjectAltNamesPassthrough" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints), global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints.Parser, new[]{ "KnownExtensions", "AdditionalExtensions" }, null, new[]{ typeof(global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints.Types.KnownCertificateExtension) }, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// A [RevocationReason][google.cloud.security.privateca.v1.RevocationReason] indicates whether a [Certificate][google.cloud.security.privateca.v1.Certificate] has been revoked,
  /// and the reason for revocation. These correspond to standard revocation
  /// reasons from RFC 5280. Note that the enum labels and values in this
  /// definition are not the same ASN.1 values defined in RFC 5280. These values
  /// will be translated to the correct ASN.1 values when a CRL is created.
  /// </summary>
  public enum RevocationReason {
    /// <summary>
    /// Default unspecified value. This value does indicate that a [Certificate][google.cloud.security.privateca.v1.Certificate]
    /// has been revoked, but that a reason has not been recorded.
    /// </summary>
    [pbr::OriginalName("REVOCATION_REASON_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Key material for this [Certificate][google.cloud.security.privateca.v1.Certificate] may have leaked.
    /// </summary>
    [pbr::OriginalName("KEY_COMPROMISE")] KeyCompromise = 1,
    /// <summary>
    /// The key material for a certificate authority in the issuing path may have
    /// leaked.
    /// </summary>
    [pbr::OriginalName("CERTIFICATE_AUTHORITY_COMPROMISE")] CertificateAuthorityCompromise = 2,
    /// <summary>
    /// The subject or other attributes in this [Certificate][google.cloud.security.privateca.v1.Certificate] have changed.
    /// </summary>
    [pbr::OriginalName("AFFILIATION_CHANGED")] AffiliationChanged = 3,
    /// <summary>
    /// This [Certificate][google.cloud.security.privateca.v1.Certificate] has been superseded.
    /// </summary>
    [pbr::OriginalName("SUPERSEDED")] Superseded = 4,
    /// <summary>
    /// This [Certificate][google.cloud.security.privateca.v1.Certificate] or entities in the issuing path have ceased to
    /// operate.
    /// </summary>
    [pbr::OriginalName("CESSATION_OF_OPERATION")] CessationOfOperation = 5,
    /// <summary>
    /// This [Certificate][google.cloud.security.privateca.v1.Certificate] should not be considered valid, it is expected that it
    /// may become valid in the future.
    /// </summary>
    [pbr::OriginalName("CERTIFICATE_HOLD")] CertificateHold = 6,
    /// <summary>
    /// This [Certificate][google.cloud.security.privateca.v1.Certificate] no longer has permission to assert the listed
    /// attributes.
    /// </summary>
    [pbr::OriginalName("PRIVILEGE_WITHDRAWN")] PrivilegeWithdrawn = 7,
    /// <summary>
    /// The authority which determines appropriate attributes for a [Certificate][google.cloud.security.privateca.v1.Certificate]
    /// may have been compromised.
    /// </summary>
    [pbr::OriginalName("ATTRIBUTE_AUTHORITY_COMPROMISE")] AttributeAuthorityCompromise = 8,
  }

  /// <summary>
  /// Describes the way in which a [Certificate][google.cloud.security.privateca.v1.Certificate]'s [Subject][google.cloud.security.privateca.v1.Subject] and/or
  /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] will be resolved.
  /// </summary>
  public enum SubjectRequestMode {
    /// <summary>
    /// Not specified.
    /// </summary>
    [pbr::OriginalName("SUBJECT_REQUEST_MODE_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// The default mode used in most cases. Indicates that the certificate's
    /// [Subject][google.cloud.security.privateca.v1.Subject] and/or [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] are specified in the certificate
    /// request. This mode requires the caller to have the
    /// `privateca.certificates.create` permission.
    /// </summary>
    [pbr::OriginalName("DEFAULT")] Default = 1,
    /// <summary>
    /// A mode reserved for special cases. Indicates that the certificate should
    /// have one or more SPIFFE [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] set by the service based
    /// on the caller's identity. This mode will ignore any explicitly specified
    /// [Subject][google.cloud.security.privateca.v1.Subject] and/or [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] in the certificate request.
    /// This mode requires the caller to have the
    /// `privateca.certificates.createForSelf` permission.
    /// </summary>
    [pbr::OriginalName("REFLECTED_SPIFFE")] ReflectedSpiffe = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// A [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] represents an individual Certificate Authority.
  /// A [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] can be used to create [Certificates][google.cloud.security.privateca.v1.Certificate].
  /// </summary>
  public sealed partial class CertificateAuthority : pb::IMessage<CertificateAuthority>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateAuthority> _parser = new pb::MessageParser<CertificateAuthority>(() => new CertificateAuthority());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateAuthority> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateAuthority() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateAuthority(CertificateAuthority other) : this() {
      name_ = other.name_;
      type_ = other.type_;
      config_ = other.config_ != null ? other.config_.Clone() : null;
      lifetime_ = other.lifetime_ != null ? other.lifetime_.Clone() : null;
      keySpec_ = other.keySpec_ != null ? other.keySpec_.Clone() : null;
      subordinateConfig_ = other.subordinateConfig_ != null ? other.subordinateConfig_.Clone() : null;
      tier_ = other.tier_;
      state_ = other.state_;
      pemCaCertificates_ = other.pemCaCertificates_.Clone();
      caCertificateDescriptions_ = other.caCertificateDescriptions_.Clone();
      gcsBucket_ = other.gcsBucket_;
      accessUrls_ = other.accessUrls_ != null ? other.accessUrls_.Clone() : null;
      createTime_ = other.createTime_ != null ? other.createTime_.Clone() : null;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      deleteTime_ = other.deleteTime_ != null ? other.deleteTime_.Clone() : null;
      expireTime_ = other.expireTime_ != null ? other.expireTime_.Clone() : null;
      labels_ = other.labels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateAuthority Clone() {
      return new CertificateAuthority(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The resource name for this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] in the
    /// format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type type_ = global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type.Unspecified;
    /// <summary>
    /// Required. Immutable. The [Type][google.cloud.security.privateca.v1.CertificateAuthority.Type] of this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 3;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig config_;
    /// <summary>
    /// Required. Immutable. The config used to create a self-signed X.509 certificate or CSR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "lifetime" field.</summary>
    public const int LifetimeFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration lifetime_;
    /// <summary>
    /// Required. The desired lifetime of the CA certificate. Used to create the
    /// "not_before_time" and "not_after_time" fields inside an X.509
    /// certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Lifetime {
      get { return lifetime_; }
      set {
        lifetime_ = value;
      }
    }

    /// <summary>Field number for the "key_spec" field.</summary>
    public const int KeySpecFieldNumber = 5;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.KeyVersionSpec keySpec_;
    /// <summary>
    /// Required. Immutable. Used when issuing certificates for this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]. If this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] is a self-signed CertificateAuthority, this key
    /// is also used to sign the self-signed CA certificate. Otherwise, it
    /// is used to sign a CSR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.KeyVersionSpec KeySpec {
      get { return keySpec_; }
      set {
        keySpec_ = value;
      }
    }

    /// <summary>Field number for the "subordinate_config" field.</summary>
    public const int SubordinateConfigFieldNumber = 6;
    private global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig subordinateConfig_;
    /// <summary>
    /// Optional. If this is a subordinate [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority], this field will be set
    /// with the subordinate configuration, which describes its issuers. This may
    /// be updated, but this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] must continue to validate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig SubordinateConfig {
      get { return subordinateConfig_; }
      set {
        subordinateConfig_ = value;
      }
    }

    /// <summary>Field number for the "tier" field.</summary>
    public const int TierFieldNumber = 7;
    private global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier tier_ = global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified;
    /// <summary>
    /// Output only. The [CaPool.Tier][google.cloud.security.privateca.v1.CaPool.Tier] of the [CaPool][google.cloud.security.privateca.v1.CaPool] that includes this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier Tier {
      get { return tier_; }
      set {
        tier_ = value;
      }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 8;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State state_ = global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State.Unspecified;
    /// <summary>
    /// Output only. The [State][google.cloud.security.privateca.v1.CertificateAuthority.State] for this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    /// <summary>Field number for the "pem_ca_certificates" field.</summary>
    public const int PemCaCertificatesFieldNumber = 9;
    private static readonly pb::FieldCodec<string> _repeated_pemCaCertificates_codec
        = pb::FieldCodec.ForString(74);
    private readonly pbc::RepeatedField<string> pemCaCertificates_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Output only. This [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s certificate chain, including the current
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s certificate. Ordered such that the root issuer
    /// is the final element (consistent with RFC 5246). For a self-signed CA, this
    /// will only list the current [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> PemCaCertificates {
      get { return pemCaCertificates_; }
    }

    /// <summary>Field number for the "ca_certificate_descriptions" field.</summary>
    public const int CaCertificateDescriptionsFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription> _repeated_caCertificateDescriptions_codec
        = pb::FieldCodec.ForMessage(82, global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription> caCertificateDescriptions_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription>();
    /// <summary>
    /// Output only. A structured description of this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s CA certificate
    /// and its issuers. Ordered as self-to-root.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription> CaCertificateDescriptions {
      get { return caCertificateDescriptions_; }
    }

    /// <summary>Field number for the "gcs_bucket" field.</summary>
    public const int GcsBucketFieldNumber = 11;
    private string gcsBucket_ = "";
    /// <summary>
    /// Immutable. The name of a Cloud Storage bucket where this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] will
    /// publish content, such as the CA certificate and CRLs. This must be a bucket
    /// name, without any prefixes (such as `gs://`) or suffixes (such as
    /// `.googleapis.com`). For example, to use a bucket named `my-bucket`, you
    /// would simply specify `my-bucket`. If not specified, a managed bucket will
    /// be created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GcsBucket {
      get { return gcsBucket_; }
      set {
        gcsBucket_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "access_urls" field.</summary>
    public const int AccessUrlsFieldNumber = 12;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.AccessUrls accessUrls_;
    /// <summary>
    /// Output only. URLs for accessing content published by this CA, such as the CA certificate
    /// and CRLs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.AccessUrls AccessUrls {
      get { return accessUrls_; }
      set {
        accessUrls_ = value;
      }
    }

    /// <summary>Field number for the "create_time" field.</summary>
    public const int CreateTimeFieldNumber = 13;
    private global::Google.Protobuf.WellKnownTypes.Timestamp createTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] was created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreateTime {
      get { return createTime_; }
      set {
        createTime_ = value;
      }
    }

    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 14;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] was last updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "delete_time" field.</summary>
    public const int DeleteTimeFieldNumber = 15;
    private global::Google.Protobuf.WellKnownTypes.Timestamp deleteTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] was soft deleted, if
    /// it is in the [DELETED][google.cloud.security.privateca.v1.CertificateAuthority.State.DELETED] state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp DeleteTime {
      get { return deleteTime_; }
      set {
        deleteTime_ = value;
      }
    }

    /// <summary>Field number for the "expire_time" field.</summary>
    public const int ExpireTimeFieldNumber = 16;
    private global::Google.Protobuf.WellKnownTypes.Timestamp expireTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] will be permanently purged,
    /// if it is in the [DELETED][google.cloud.security.privateca.v1.CertificateAuthority.State.DELETED] state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp ExpireTime {
      get { return expireTime_; }
      set {
        expireTime_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 17;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 138);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels with user-defined metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateAuthority);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateAuthority other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(Config, other.Config)) return false;
      if (!object.Equals(Lifetime, other.Lifetime)) return false;
      if (!object.Equals(KeySpec, other.KeySpec)) return false;
      if (!object.Equals(SubordinateConfig, other.SubordinateConfig)) return false;
      if (Tier != other.Tier) return false;
      if (State != other.State) return false;
      if(!pemCaCertificates_.Equals(other.pemCaCertificates_)) return false;
      if(!caCertificateDescriptions_.Equals(other.caCertificateDescriptions_)) return false;
      if (GcsBucket != other.GcsBucket) return false;
      if (!object.Equals(AccessUrls, other.AccessUrls)) return false;
      if (!object.Equals(CreateTime, other.CreateTime)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (!object.Equals(DeleteTime, other.DeleteTime)) return false;
      if (!object.Equals(ExpireTime, other.ExpireTime)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Type != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type.Unspecified) hash ^= Type.GetHashCode();
      if (config_ != null) hash ^= Config.GetHashCode();
      if (lifetime_ != null) hash ^= Lifetime.GetHashCode();
      if (keySpec_ != null) hash ^= KeySpec.GetHashCode();
      if (subordinateConfig_ != null) hash ^= SubordinateConfig.GetHashCode();
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) hash ^= Tier.GetHashCode();
      if (State != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State.Unspecified) hash ^= State.GetHashCode();
      hash ^= pemCaCertificates_.GetHashCode();
      hash ^= caCertificateDescriptions_.GetHashCode();
      if (GcsBucket.Length != 0) hash ^= GcsBucket.GetHashCode();
      if (accessUrls_ != null) hash ^= AccessUrls.GetHashCode();
      if (createTime_ != null) hash ^= CreateTime.GetHashCode();
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      if (deleteTime_ != null) hash ^= DeleteTime.GetHashCode();
      if (expireTime_ != null) hash ^= ExpireTime.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Type != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (config_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Config);
      }
      if (lifetime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Lifetime);
      }
      if (keySpec_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(KeySpec);
      }
      if (subordinateConfig_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SubordinateConfig);
      }
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Tier);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State.Unspecified) {
        output.WriteRawTag(64);
        output.WriteEnum((int) State);
      }
      pemCaCertificates_.WriteTo(output, _repeated_pemCaCertificates_codec);
      caCertificateDescriptions_.WriteTo(output, _repeated_caCertificateDescriptions_codec);
      if (GcsBucket.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(GcsBucket);
      }
      if (accessUrls_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(AccessUrls);
      }
      if (createTime_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(UpdateTime);
      }
      if (deleteTime_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(DeleteTime);
      }
      if (expireTime_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(ExpireTime);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Type != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (config_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Config);
      }
      if (lifetime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Lifetime);
      }
      if (keySpec_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(KeySpec);
      }
      if (subordinateConfig_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SubordinateConfig);
      }
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Tier);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State.Unspecified) {
        output.WriteRawTag(64);
        output.WriteEnum((int) State);
      }
      pemCaCertificates_.WriteTo(ref output, _repeated_pemCaCertificates_codec);
      caCertificateDescriptions_.WriteTo(ref output, _repeated_caCertificateDescriptions_codec);
      if (GcsBucket.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(GcsBucket);
      }
      if (accessUrls_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(AccessUrls);
      }
      if (createTime_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(UpdateTime);
      }
      if (deleteTime_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(DeleteTime);
      }
      if (expireTime_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(ExpireTime);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Type != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (lifetime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lifetime);
      }
      if (keySpec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeySpec);
      }
      if (subordinateConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubordinateConfig);
      }
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Tier);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      size += pemCaCertificates_.CalculateSize(_repeated_pemCaCertificates_codec);
      size += caCertificateDescriptions_.CalculateSize(_repeated_caCertificateDescriptions_codec);
      if (GcsBucket.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GcsBucket);
      }
      if (accessUrls_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccessUrls);
      }
      if (createTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreateTime);
      }
      if (updateTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      if (deleteTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeleteTime);
      }
      if (expireTime_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ExpireTime);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateAuthority other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Type != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type.Unspecified) {
        Type = other.Type;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          Config = new global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.lifetime_ != null) {
        if (lifetime_ == null) {
          Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Lifetime.MergeFrom(other.Lifetime);
      }
      if (other.keySpec_ != null) {
        if (keySpec_ == null) {
          KeySpec = new global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.KeyVersionSpec();
        }
        KeySpec.MergeFrom(other.KeySpec);
      }
      if (other.subordinateConfig_ != null) {
        if (subordinateConfig_ == null) {
          SubordinateConfig = new global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig();
        }
        SubordinateConfig.MergeFrom(other.SubordinateConfig);
      }
      if (other.Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) {
        Tier = other.Tier;
      }
      if (other.State != global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State.Unspecified) {
        State = other.State;
      }
      pemCaCertificates_.Add(other.pemCaCertificates_);
      caCertificateDescriptions_.Add(other.caCertificateDescriptions_);
      if (other.GcsBucket.Length != 0) {
        GcsBucket = other.GcsBucket;
      }
      if (other.accessUrls_ != null) {
        if (accessUrls_ == null) {
          AccessUrls = new global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.AccessUrls();
        }
        AccessUrls.MergeFrom(other.AccessUrls);
      }
      if (other.createTime_ != null) {
        if (createTime_ == null) {
          CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreateTime.MergeFrom(other.CreateTime);
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      if (other.deleteTime_ != null) {
        if (deleteTime_ == null) {
          DeleteTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        DeleteTime.MergeFrom(other.DeleteTime);
      }
      if (other.expireTime_ != null) {
        if (expireTime_ == null) {
          ExpireTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        ExpireTime.MergeFrom(other.ExpireTime);
      }
      labels_.Add(other.labels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Type = (global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type) input.ReadEnum();
            break;
          }
          case 26: {
            if (config_ == null) {
              Config = new global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig();
            }
            input.ReadMessage(Config);
            break;
          }
          case 34: {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lifetime);
            break;
          }
          case 42: {
            if (keySpec_ == null) {
              KeySpec = new global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.KeyVersionSpec();
            }
            input.ReadMessage(KeySpec);
            break;
          }
          case 50: {
            if (subordinateConfig_ == null) {
              SubordinateConfig = new global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig();
            }
            input.ReadMessage(SubordinateConfig);
            break;
          }
          case 56: {
            Tier = (global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier) input.ReadEnum();
            break;
          }
          case 64: {
            State = (global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State) input.ReadEnum();
            break;
          }
          case 74: {
            pemCaCertificates_.AddEntriesFrom(input, _repeated_pemCaCertificates_codec);
            break;
          }
          case 82: {
            caCertificateDescriptions_.AddEntriesFrom(input, _repeated_caCertificateDescriptions_codec);
            break;
          }
          case 90: {
            GcsBucket = input.ReadString();
            break;
          }
          case 98: {
            if (accessUrls_ == null) {
              AccessUrls = new global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.AccessUrls();
            }
            input.ReadMessage(AccessUrls);
            break;
          }
          case 106: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 114: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 122: {
            if (deleteTime_ == null) {
              DeleteTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(DeleteTime);
            break;
          }
          case 130: {
            if (expireTime_ == null) {
              ExpireTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ExpireTime);
            break;
          }
          case 138: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Type = (global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.Type) input.ReadEnum();
            break;
          }
          case 26: {
            if (config_ == null) {
              Config = new global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig();
            }
            input.ReadMessage(Config);
            break;
          }
          case 34: {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lifetime);
            break;
          }
          case 42: {
            if (keySpec_ == null) {
              KeySpec = new global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.KeyVersionSpec();
            }
            input.ReadMessage(KeySpec);
            break;
          }
          case 50: {
            if (subordinateConfig_ == null) {
              SubordinateConfig = new global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig();
            }
            input.ReadMessage(SubordinateConfig);
            break;
          }
          case 56: {
            Tier = (global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier) input.ReadEnum();
            break;
          }
          case 64: {
            State = (global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.State) input.ReadEnum();
            break;
          }
          case 74: {
            pemCaCertificates_.AddEntriesFrom(ref input, _repeated_pemCaCertificates_codec);
            break;
          }
          case 82: {
            caCertificateDescriptions_.AddEntriesFrom(ref input, _repeated_caCertificateDescriptions_codec);
            break;
          }
          case 90: {
            GcsBucket = input.ReadString();
            break;
          }
          case 98: {
            if (accessUrls_ == null) {
              AccessUrls = new global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.AccessUrls();
            }
            input.ReadMessage(AccessUrls);
            break;
          }
          case 106: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 114: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 122: {
            if (deleteTime_ == null) {
              DeleteTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(DeleteTime);
            break;
          }
          case 130: {
            if (expireTime_ == null) {
              ExpireTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ExpireTime);
            break;
          }
          case 138: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateAuthority message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The type of a [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority], indicating its issuing chain.
      /// </summary>
      public enum Type {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Self-signed CA.
        /// </summary>
        [pbr::OriginalName("SELF_SIGNED")] SelfSigned = 1,
        /// <summary>
        /// Subordinate CA. Could be issued by a Private CA [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
        /// or an unmanaged CA.
        /// </summary>
        [pbr::OriginalName("SUBORDINATE")] Subordinate = 2,
      }

      /// <summary>
      /// The state of a [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority], indicating if it can be used.
      /// </summary>
      public enum State {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("STATE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Certificates can be issued from this CA. CRLs will be generated for this
        /// CA. The CA will be part of the [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, and will be
        /// used to issue certificates from the [CaPool][google.cloud.security.privateca.v1.CaPool].
        /// </summary>
        [pbr::OriginalName("ENABLED")] Enabled = 1,
        /// <summary>
        /// Certificates cannot be issued from this CA. CRLs will still be generated.
        /// The CA will be part of the [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, but will not be
        /// used to issue certificates from the [CaPool][google.cloud.security.privateca.v1.CaPool].
        /// </summary>
        [pbr::OriginalName("DISABLED")] Disabled = 2,
        /// <summary>
        /// Certificates can be issued from this CA. CRLs will be generated for this
        /// CA. The CA will be part of the [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, but will not
        /// be used to issue certificates from the [CaPool][google.cloud.security.privateca.v1.CaPool].
        /// </summary>
        [pbr::OriginalName("STAGED")] Staged = 3,
        /// <summary>
        /// Certificates cannot be issued from this CA. CRLs will not be generated.
        /// The CA will not be part of the [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, and will not be
        /// used to issue certificates from the [CaPool][google.cloud.security.privateca.v1.CaPool].
        /// </summary>
        [pbr::OriginalName("AWAITING_USER_ACTIVATION")] AwaitingUserActivation = 4,
        /// <summary>
        /// Certificates cannot be issued from this CA. CRLs will not be generated.
        /// The CA may still be recovered by calling
        /// [CertificateAuthorityService.UndeleteCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.UndeleteCertificateAuthority] before
        /// [expire_time][google.cloud.security.privateca.v1.CertificateAuthority.expire_time].
        /// The CA will not be part of the [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, and will not be
        /// used to issue certificates from the [CaPool][google.cloud.security.privateca.v1.CaPool].
        /// </summary>
        [pbr::OriginalName("DELETED")] Deleted = 5,
      }

      /// <summary>
      /// The algorithm of a Cloud KMS CryptoKeyVersion of a
      /// [CryptoKey][google.cloud.kms.v1.CryptoKey] with the
      /// [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose] value
      /// `ASYMMETRIC_SIGN`. These values correspond to the
      /// [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
      /// values. For RSA signing algorithms, the PSS algorithms should be preferred,
      /// use PKCS1 algorithms if required for compatibility. For further
      /// recommandations, see
      /// https://cloud.google.com/kms/docs/algorithms#algorithm_recommendations.
      /// </summary>
      public enum SignHashAlgorithm {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("SIGN_HASH_ALGORITHM_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PSS_2048_SHA256")] RsaPss2048Sha256 = 1,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm. RSA_SIGN_PSS_3072_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PSS_3072_SHA256")] RsaPss3072Sha256 = 2,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PSS_4096_SHA256")] RsaPss4096Sha256 = 3,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PKCS1_2048_SHA256")] RsaPkcs12048Sha256 = 6,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PKCS1_3072_SHA256")] RsaPkcs13072Sha256 = 7,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256
        /// </summary>
        [pbr::OriginalName("RSA_PKCS1_4096_SHA256")] RsaPkcs14096Sha256 = 8,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256
        /// </summary>
        [pbr::OriginalName("EC_P256_SHA256")] EcP256Sha256 = 4,
        /// <summary>
        /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384
        /// </summary>
        [pbr::OriginalName("EC_P384_SHA384")] EcP384Sha384 = 5,
      }

      /// <summary>
      /// URLs where a [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] will publish content.
      /// </summary>
      public sealed partial class AccessUrls : pb::IMessage<AccessUrls>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<AccessUrls> _parser = new pb::MessageParser<AccessUrls>(() => new AccessUrls());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AccessUrls> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AccessUrls() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AccessUrls(AccessUrls other) : this() {
          caCertificateAccessUrl_ = other.caCertificateAccessUrl_;
          crlAccessUrls_ = other.crlAccessUrls_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AccessUrls Clone() {
          return new AccessUrls(this);
        }

        /// <summary>Field number for the "ca_certificate_access_url" field.</summary>
        public const int CaCertificateAccessUrlFieldNumber = 1;
        private string caCertificateAccessUrl_ = "";
        /// <summary>
        /// The URL where this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s CA certificate is
        /// published. This will only be set for CAs that have been activated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CaCertificateAccessUrl {
          get { return caCertificateAccessUrl_; }
          set {
            caCertificateAccessUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "crl_access_urls" field.</summary>
        public const int CrlAccessUrlsFieldNumber = 2;
        private static readonly pb::FieldCodec<string> _repeated_crlAccessUrls_codec
            = pb::FieldCodec.ForString(18);
        private readonly pbc::RepeatedField<string> crlAccessUrls_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// The URLs where this [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s CRLs are published. This
        /// will only be set for CAs that have been activated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> CrlAccessUrls {
          get { return crlAccessUrls_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AccessUrls);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AccessUrls other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (CaCertificateAccessUrl != other.CaCertificateAccessUrl) return false;
          if(!crlAccessUrls_.Equals(other.crlAccessUrls_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (CaCertificateAccessUrl.Length != 0) hash ^= CaCertificateAccessUrl.GetHashCode();
          hash ^= crlAccessUrls_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (CaCertificateAccessUrl.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(CaCertificateAccessUrl);
          }
          crlAccessUrls_.WriteTo(output, _repeated_crlAccessUrls_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (CaCertificateAccessUrl.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(CaCertificateAccessUrl);
          }
          crlAccessUrls_.WriteTo(ref output, _repeated_crlAccessUrls_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (CaCertificateAccessUrl.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CaCertificateAccessUrl);
          }
          size += crlAccessUrls_.CalculateSize(_repeated_crlAccessUrls_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AccessUrls other) {
          if (other == null) {
            return;
          }
          if (other.CaCertificateAccessUrl.Length != 0) {
            CaCertificateAccessUrl = other.CaCertificateAccessUrl;
          }
          crlAccessUrls_.Add(other.crlAccessUrls_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                CaCertificateAccessUrl = input.ReadString();
                break;
              }
              case 18: {
                crlAccessUrls_.AddEntriesFrom(input, _repeated_crlAccessUrls_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                CaCertificateAccessUrl = input.ReadString();
                break;
              }
              case 18: {
                crlAccessUrls_.AddEntriesFrom(ref input, _repeated_crlAccessUrls_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// A Cloud KMS key configuration that a [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] will use.
      /// </summary>
      public sealed partial class KeyVersionSpec : pb::IMessage<KeyVersionSpec>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<KeyVersionSpec> _parser = new pb::MessageParser<KeyVersionSpec>(() => new KeyVersionSpec());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<KeyVersionSpec> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyVersionSpec() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyVersionSpec(KeyVersionSpec other) : this() {
          switch (other.KeyVersionCase) {
            case KeyVersionOneofCase.CloudKmsKeyVersion:
              CloudKmsKeyVersion = other.CloudKmsKeyVersion;
              break;
            case KeyVersionOneofCase.Algorithm:
              Algorithm = other.Algorithm;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyVersionSpec Clone() {
          return new KeyVersionSpec(this);
        }

        /// <summary>Field number for the "cloud_kms_key_version" field.</summary>
        public const int CloudKmsKeyVersionFieldNumber = 1;
        /// <summary>
        /// The resource name for an existing Cloud KMS CryptoKeyVersion in the
        /// format
        /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/cryptoKeyVersions/*`.
        /// This option enables full flexibility in the key's capabilities and
        /// properties.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CloudKmsKeyVersion {
          get { return keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion ? (string) keyVersion_ : ""; }
          set {
            keyVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            keyVersionCase_ = KeyVersionOneofCase.CloudKmsKeyVersion;
          }
        }

        /// <summary>Field number for the "algorithm" field.</summary>
        public const int AlgorithmFieldNumber = 2;
        /// <summary>
        /// The algorithm to use for creating a managed Cloud KMS key for a for a
        /// simplified experience. All managed keys will be have their
        /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] as `HSM`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.SignHashAlgorithm Algorithm {
          get { return keyVersionCase_ == KeyVersionOneofCase.Algorithm ? (global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.SignHashAlgorithm) keyVersion_ : global::Google.Cloud.Security.PrivateCA.V1.CertificateAuthority.Types.SignHashAlgorithm.Unspecified; }
          set {
            keyVersion_ = value;
            keyVersionCase_ = KeyVersionOneofCase.Algorithm;
          }
        }

        private object keyVersion_;
        /// <summary>Enum of possible cases for the "KeyVersion" oneof.</summary>
        public enum KeyVersionOneofCase {
          None = 0,
          CloudKmsKeyVersion = 1,
          Algorithm = 2,
        }
        private KeyVersionOneofCase keyVersionCase_ = KeyVersionOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyVersionOneofCase KeyVersionCase {
          get { return keyVersionCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearKeyVersion() {
          keyVersionCase_ = KeyVersionOneofCase.None;
          keyVersion_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as KeyVersionSpec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(KeyVersionSpec other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (CloudKmsKeyVersion != other.CloudKmsKeyVersion) return false;
          if (Algorithm != other.Algorithm) return false;
          if (KeyVersionCase != other.KeyVersionCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion) hash ^= CloudKmsKeyVersion.GetHashCode();
          if (keyVersionCase_ == KeyVersionOneofCase.Algorithm) hash ^= Algorithm.GetHashCode();
          hash ^= (int) keyVersionCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion) {
            output.WriteRawTag(10);
            output.WriteString(CloudKmsKeyVersion);
          }
          if (keyVersionCase_ == KeyVersionOneofCase.Algorithm) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Algorithm);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion) {
            output.WriteRawTag(10);
            output.WriteString(CloudKmsKeyVersion);
          }
          if (keyVersionCase_ == KeyVersionOneofCase.Algorithm) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Algorithm);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (keyVersionCase_ == KeyVersionOneofCase.CloudKmsKeyVersion) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CloudKmsKeyVersion);
          }
          if (keyVersionCase_ == KeyVersionOneofCase.Algorithm) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Algorithm);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(KeyVersionSpec other) {
          if (other == null) {
            return;
          }
          switch (other.KeyVersionCase) {
            case KeyVersionOneofCase.CloudKmsKeyVersion:
              CloudKmsKeyVersion = other.CloudKmsKeyVersion;
              break;
            case KeyVersionOneofCase.Algorithm:
              Algorithm = other.Algorithm;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                CloudKmsKeyVersion = input.ReadString();
                break;
              }
              case 16: {
                keyVersion_ = input.ReadEnum();
                keyVersionCase_ = KeyVersionOneofCase.Algorithm;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                CloudKmsKeyVersion = input.ReadString();
                break;
              }
              case 16: {
                keyVersion_ = input.ReadEnum();
                keyVersionCase_ = KeyVersionOneofCase.Algorithm;
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [CaPool][google.cloud.security.privateca.v1.CaPool] represents a group of
  /// [CertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthority] that form a trust anchor. A
  /// [CaPool][google.cloud.security.privateca.v1.CaPool] can be used to manage issuance policies for one or more
  /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] resources and to rotate CA certificates in and out
  /// of the trust anchor.
  /// </summary>
  public sealed partial class CaPool : pb::IMessage<CaPool>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CaPool> _parser = new pb::MessageParser<CaPool>(() => new CaPool());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CaPool> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CaPool() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CaPool(CaPool other) : this() {
      name_ = other.name_;
      tier_ = other.tier_;
      issuancePolicy_ = other.issuancePolicy_ != null ? other.issuancePolicy_.Clone() : null;
      publishingOptions_ = other.publishingOptions_ != null ? other.publishingOptions_.Clone() : null;
      labels_ = other.labels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CaPool Clone() {
      return new CaPool(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The resource name for this [CaPool][google.cloud.security.privateca.v1.CaPool] in the
    /// format `projects/*/locations/*/caPools/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tier" field.</summary>
    public const int TierFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier tier_ = global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified;
    /// <summary>
    /// Required. Immutable. The [Tier][google.cloud.security.privateca.v1.CaPool.Tier] of this [CaPool][google.cloud.security.privateca.v1.CaPool].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier Tier {
      get { return tier_; }
      set {
        tier_ = value;
      }
    }

    /// <summary>Field number for the "issuance_policy" field.</summary>
    public const int IssuancePolicyFieldNumber = 3;
    private global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy issuancePolicy_;
    /// <summary>
    /// Optional. The [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy] to control how [Certificates][google.cloud.security.privateca.v1.Certificate]
    /// will be issued from this [CaPool][google.cloud.security.privateca.v1.CaPool].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy IssuancePolicy {
      get { return issuancePolicy_; }
      set {
        issuancePolicy_ = value;
      }
    }

    /// <summary>Field number for the "publishing_options" field.</summary>
    public const int PublishingOptionsFieldNumber = 4;
    private global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.PublishingOptions publishingOptions_;
    /// <summary>
    /// Optional. The [PublishingOptions][google.cloud.security.privateca.v1.CaPool.PublishingOptions] to follow when issuing
    /// [Certificates][google.cloud.security.privateca.v1.Certificate] from any [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] in this
    /// [CaPool][google.cloud.security.privateca.v1.CaPool].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.PublishingOptions PublishingOptions {
      get { return publishingOptions_; }
      set {
        publishingOptions_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 5;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 42);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels with user-defined metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CaPool);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CaPool other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Tier != other.Tier) return false;
      if (!object.Equals(IssuancePolicy, other.IssuancePolicy)) return false;
      if (!object.Equals(PublishingOptions, other.PublishingOptions)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) hash ^= Tier.GetHashCode();
      if (issuancePolicy_ != null) hash ^= IssuancePolicy.GetHashCode();
      if (publishingOptions_ != null) hash ^= PublishingOptions.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Tier);
      }
      if (issuancePolicy_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IssuancePolicy);
      }
      if (publishingOptions_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PublishingOptions);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Tier);
      }
      if (issuancePolicy_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IssuancePolicy);
      }
      if (publishingOptions_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PublishingOptions);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Tier);
      }
      if (issuancePolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IssuancePolicy);
      }
      if (publishingOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PublishingOptions);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CaPool other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Tier != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier.Unspecified) {
        Tier = other.Tier;
      }
      if (other.issuancePolicy_ != null) {
        if (issuancePolicy_ == null) {
          IssuancePolicy = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy();
        }
        IssuancePolicy.MergeFrom(other.IssuancePolicy);
      }
      if (other.publishingOptions_ != null) {
        if (publishingOptions_ == null) {
          PublishingOptions = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.PublishingOptions();
        }
        PublishingOptions.MergeFrom(other.PublishingOptions);
      }
      labels_.Add(other.labels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Tier = (global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier) input.ReadEnum();
            break;
          }
          case 26: {
            if (issuancePolicy_ == null) {
              IssuancePolicy = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy();
            }
            input.ReadMessage(IssuancePolicy);
            break;
          }
          case 34: {
            if (publishingOptions_ == null) {
              PublishingOptions = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.PublishingOptions();
            }
            input.ReadMessage(PublishingOptions);
            break;
          }
          case 42: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Tier = (global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.Tier) input.ReadEnum();
            break;
          }
          case 26: {
            if (issuancePolicy_ == null) {
              IssuancePolicy = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy();
            }
            input.ReadMessage(IssuancePolicy);
            break;
          }
          case 34: {
            if (publishingOptions_ == null) {
              PublishingOptions = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.PublishingOptions();
            }
            input.ReadMessage(PublishingOptions);
            break;
          }
          case 42: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CaPool message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The tier of a [CaPool][google.cloud.security.privateca.v1.CaPool], indicating its supported functionality and/or
      /// billing SKU.
      /// </summary>
      public enum Tier {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("TIER_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Enterprise tier.
        /// </summary>
        [pbr::OriginalName("ENTERPRISE")] Enterprise = 1,
        /// <summary>
        /// DevOps tier.
        /// </summary>
        [pbr::OriginalName("DEVOPS")] Devops = 2,
      }

      /// <summary>
      /// Options relating to the publication of each [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s CA
      /// certificate and CRLs and their inclusion as extensions in issued
      /// [Certificates][google.cloud.security.privateca.v1.Certificate]. The options set here apply to certificates
      /// issued by any [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] in the [CaPool][google.cloud.security.privateca.v1.CaPool].
      /// </summary>
      public sealed partial class PublishingOptions : pb::IMessage<PublishingOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PublishingOptions> _parser = new pb::MessageParser<PublishingOptions>(() => new PublishingOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PublishingOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.CaPool.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PublishingOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PublishingOptions(PublishingOptions other) : this() {
          publishCaCert_ = other.publishCaCert_;
          publishCrl_ = other.publishCrl_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PublishingOptions Clone() {
          return new PublishingOptions(this);
        }

        /// <summary>Field number for the "publish_ca_cert" field.</summary>
        public const int PublishCaCertFieldNumber = 1;
        private bool publishCaCert_;
        /// <summary>
        /// Required. When true, publishes each [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s CA certificate and
        /// includes its URL in the "Authority Information Access" X.509 extension
        /// in all issued [Certificates][google.cloud.security.privateca.v1.Certificate]. If this is false, the CA
        /// certificate will not be published and the corresponding X.509 extension
        /// will not be written in issued certificates.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool PublishCaCert {
          get { return publishCaCert_; }
          set {
            publishCaCert_ = value;
          }
        }

        /// <summary>Field number for the "publish_crl" field.</summary>
        public const int PublishCrlFieldNumber = 2;
        private bool publishCrl_;
        /// <summary>
        /// Required. When true, publishes each [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s CRL and includes its
        /// URL in the "CRL Distribution Points" X.509 extension in all issued
        /// [Certificates][google.cloud.security.privateca.v1.Certificate]. If this is false, CRLs will not be published
        /// and the corresponding X.509 extension will not be written in issued
        /// certificates.
        /// CRLs will expire 7 days from their creation. However, we will rebuild
        /// daily. CRLs are also rebuilt shortly after a certificate is revoked.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool PublishCrl {
          get { return publishCrl_; }
          set {
            publishCrl_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as PublishingOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PublishingOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (PublishCaCert != other.PublishCaCert) return false;
          if (PublishCrl != other.PublishCrl) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (PublishCaCert != false) hash ^= PublishCaCert.GetHashCode();
          if (PublishCrl != false) hash ^= PublishCrl.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (PublishCaCert != false) {
            output.WriteRawTag(8);
            output.WriteBool(PublishCaCert);
          }
          if (PublishCrl != false) {
            output.WriteRawTag(16);
            output.WriteBool(PublishCrl);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (PublishCaCert != false) {
            output.WriteRawTag(8);
            output.WriteBool(PublishCaCert);
          }
          if (PublishCrl != false) {
            output.WriteRawTag(16);
            output.WriteBool(PublishCrl);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (PublishCaCert != false) {
            size += 1 + 1;
          }
          if (PublishCrl != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PublishingOptions other) {
          if (other == null) {
            return;
          }
          if (other.PublishCaCert != false) {
            PublishCaCert = other.PublishCaCert;
          }
          if (other.PublishCrl != false) {
            PublishCrl = other.PublishCrl;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                PublishCaCert = input.ReadBool();
                break;
              }
              case 16: {
                PublishCrl = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                PublishCaCert = input.ReadBool();
                break;
              }
              case 16: {
                PublishCrl = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Defines controls over all certificate issuance within a [CaPool][google.cloud.security.privateca.v1.CaPool].
      /// </summary>
      public sealed partial class IssuancePolicy : pb::IMessage<IssuancePolicy>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<IssuancePolicy> _parser = new pb::MessageParser<IssuancePolicy>(() => new IssuancePolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<IssuancePolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.CaPool.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public IssuancePolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public IssuancePolicy(IssuancePolicy other) : this() {
          allowedKeyTypes_ = other.allowedKeyTypes_.Clone();
          maximumLifetime_ = other.maximumLifetime_ != null ? other.maximumLifetime_.Clone() : null;
          allowedIssuanceModes_ = other.allowedIssuanceModes_ != null ? other.allowedIssuanceModes_.Clone() : null;
          baselineValues_ = other.baselineValues_ != null ? other.baselineValues_.Clone() : null;
          identityConstraints_ = other.identityConstraints_ != null ? other.identityConstraints_.Clone() : null;
          passthroughExtensions_ = other.passthroughExtensions_ != null ? other.passthroughExtensions_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public IssuancePolicy Clone() {
          return new IssuancePolicy(this);
        }

        /// <summary>Field number for the "allowed_key_types" field.</summary>
        public const int AllowedKeyTypesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType> _repeated_allowedKeyTypes_codec
            = pb::FieldCodec.ForMessage(10, global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Parser);
        private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType> allowedKeyTypes_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType>();
        /// <summary>
        /// Optional. If any [AllowedKeyType][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType] is specified, then the certificate request's
        /// public key must match one of the key types listed here. Otherwise,
        /// any key may be used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType> AllowedKeyTypes {
          get { return allowedKeyTypes_; }
        }

        /// <summary>Field number for the "maximum_lifetime" field.</summary>
        public const int MaximumLifetimeFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration maximumLifetime_;
        /// <summary>
        /// Optional. The maximum lifetime allowed for issued [Certificates][google.cloud.security.privateca.v1.Certificate]. Note
        /// that if the issuing [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] expires before a
        /// [Certificate][google.cloud.security.privateca.v1.Certificate]'s requested maximum_lifetime, the effective lifetime will
        /// be explicitly truncated to match it.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration MaximumLifetime {
          get { return maximumLifetime_; }
          set {
            maximumLifetime_ = value;
          }
        }

        /// <summary>Field number for the "allowed_issuance_modes" field.</summary>
        public const int AllowedIssuanceModesFieldNumber = 3;
        private global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.IssuanceModes allowedIssuanceModes_;
        /// <summary>
        /// Optional. If specified, then only methods allowed in the [IssuanceModes][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.IssuanceModes] may be
        /// used to issue [Certificates][google.cloud.security.privateca.v1.Certificate].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.IssuanceModes AllowedIssuanceModes {
          get { return allowedIssuanceModes_; }
          set {
            allowedIssuanceModes_ = value;
          }
        }

        /// <summary>Field number for the "baseline_values" field.</summary>
        public const int BaselineValuesFieldNumber = 4;
        private global::Google.Cloud.Security.PrivateCA.V1.X509Parameters baselineValues_;
        /// <summary>
        /// Optional. A set of X.509 values that will be applied to all certificates issued
        /// through this [CaPool][google.cloud.security.privateca.v1.CaPool]. If a certificate request includes conflicting
        /// values for the same properties, they will be overwritten by the values
        /// defined here. If a certificate request uses a [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
        /// that defines conflicting
        /// [predefined_values][google.cloud.security.privateca.v1.CertificateTemplate.predefined_values] for the same
        /// properties, the certificate issuance request will fail.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.X509Parameters BaselineValues {
          get { return baselineValues_; }
          set {
            baselineValues_ = value;
          }
        }

        /// <summary>Field number for the "identity_constraints" field.</summary>
        public const int IdentityConstraintsFieldNumber = 5;
        private global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints identityConstraints_;
        /// <summary>
        /// Optional. Describes constraints on identities that may appear in
        /// [Certificates][google.cloud.security.privateca.v1.Certificate] issued through this [CaPool][google.cloud.security.privateca.v1.CaPool].
        /// If this is omitted, then this [CaPool][google.cloud.security.privateca.v1.CaPool] will not add restrictions on a
        /// certificate's identity.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints IdentityConstraints {
          get { return identityConstraints_; }
          set {
            identityConstraints_ = value;
          }
        }

        /// <summary>Field number for the "passthrough_extensions" field.</summary>
        public const int PassthroughExtensionsFieldNumber = 6;
        private global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints passthroughExtensions_;
        /// <summary>
        /// Optional. Describes the set of X.509 extensions that may appear in a
        /// [Certificate][google.cloud.security.privateca.v1.Certificate] issued through this [CaPool][google.cloud.security.privateca.v1.CaPool]. If a certificate request
        /// sets extensions that don't appear in the [passthrough_extensions][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.passthrough_extensions],
        /// those extensions will be dropped. If a certificate request uses a
        /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate] with
        /// [predefined_values][google.cloud.security.privateca.v1.CertificateTemplate.predefined_values] that don't
        /// appear here, the certificate issuance request will fail. If this is
        /// omitted, then this [CaPool][google.cloud.security.privateca.v1.CaPool] will not add restrictions on a
        /// certificate's X.509 extensions. These constraints do not apply to X.509
        /// extensions set in this [CaPool][google.cloud.security.privateca.v1.CaPool]'s [baseline_values][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints PassthroughExtensions {
          get { return passthroughExtensions_; }
          set {
            passthroughExtensions_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as IssuancePolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(IssuancePolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!allowedKeyTypes_.Equals(other.allowedKeyTypes_)) return false;
          if (!object.Equals(MaximumLifetime, other.MaximumLifetime)) return false;
          if (!object.Equals(AllowedIssuanceModes, other.AllowedIssuanceModes)) return false;
          if (!object.Equals(BaselineValues, other.BaselineValues)) return false;
          if (!object.Equals(IdentityConstraints, other.IdentityConstraints)) return false;
          if (!object.Equals(PassthroughExtensions, other.PassthroughExtensions)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= allowedKeyTypes_.GetHashCode();
          if (maximumLifetime_ != null) hash ^= MaximumLifetime.GetHashCode();
          if (allowedIssuanceModes_ != null) hash ^= AllowedIssuanceModes.GetHashCode();
          if (baselineValues_ != null) hash ^= BaselineValues.GetHashCode();
          if (identityConstraints_ != null) hash ^= IdentityConstraints.GetHashCode();
          if (passthroughExtensions_ != null) hash ^= PassthroughExtensions.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          allowedKeyTypes_.WriteTo(output, _repeated_allowedKeyTypes_codec);
          if (maximumLifetime_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaximumLifetime);
          }
          if (allowedIssuanceModes_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(AllowedIssuanceModes);
          }
          if (baselineValues_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(BaselineValues);
          }
          if (identityConstraints_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(IdentityConstraints);
          }
          if (passthroughExtensions_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(PassthroughExtensions);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          allowedKeyTypes_.WriteTo(ref output, _repeated_allowedKeyTypes_codec);
          if (maximumLifetime_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaximumLifetime);
          }
          if (allowedIssuanceModes_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(AllowedIssuanceModes);
          }
          if (baselineValues_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(BaselineValues);
          }
          if (identityConstraints_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(IdentityConstraints);
          }
          if (passthroughExtensions_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(PassthroughExtensions);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += allowedKeyTypes_.CalculateSize(_repeated_allowedKeyTypes_codec);
          if (maximumLifetime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaximumLifetime);
          }
          if (allowedIssuanceModes_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AllowedIssuanceModes);
          }
          if (baselineValues_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaselineValues);
          }
          if (identityConstraints_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(IdentityConstraints);
          }
          if (passthroughExtensions_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PassthroughExtensions);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(IssuancePolicy other) {
          if (other == null) {
            return;
          }
          allowedKeyTypes_.Add(other.allowedKeyTypes_);
          if (other.maximumLifetime_ != null) {
            if (maximumLifetime_ == null) {
              MaximumLifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaximumLifetime.MergeFrom(other.MaximumLifetime);
          }
          if (other.allowedIssuanceModes_ != null) {
            if (allowedIssuanceModes_ == null) {
              AllowedIssuanceModes = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.IssuanceModes();
            }
            AllowedIssuanceModes.MergeFrom(other.AllowedIssuanceModes);
          }
          if (other.baselineValues_ != null) {
            if (baselineValues_ == null) {
              BaselineValues = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
            }
            BaselineValues.MergeFrom(other.BaselineValues);
          }
          if (other.identityConstraints_ != null) {
            if (identityConstraints_ == null) {
              IdentityConstraints = new global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints();
            }
            IdentityConstraints.MergeFrom(other.IdentityConstraints);
          }
          if (other.passthroughExtensions_ != null) {
            if (passthroughExtensions_ == null) {
              PassthroughExtensions = new global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints();
            }
            PassthroughExtensions.MergeFrom(other.PassthroughExtensions);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                allowedKeyTypes_.AddEntriesFrom(input, _repeated_allowedKeyTypes_codec);
                break;
              }
              case 18: {
                if (maximumLifetime_ == null) {
                  MaximumLifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaximumLifetime);
                break;
              }
              case 26: {
                if (allowedIssuanceModes_ == null) {
                  AllowedIssuanceModes = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.IssuanceModes();
                }
                input.ReadMessage(AllowedIssuanceModes);
                break;
              }
              case 34: {
                if (baselineValues_ == null) {
                  BaselineValues = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
                }
                input.ReadMessage(BaselineValues);
                break;
              }
              case 42: {
                if (identityConstraints_ == null) {
                  IdentityConstraints = new global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints();
                }
                input.ReadMessage(IdentityConstraints);
                break;
              }
              case 50: {
                if (passthroughExtensions_ == null) {
                  PassthroughExtensions = new global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints();
                }
                input.ReadMessage(PassthroughExtensions);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                allowedKeyTypes_.AddEntriesFrom(ref input, _repeated_allowedKeyTypes_codec);
                break;
              }
              case 18: {
                if (maximumLifetime_ == null) {
                  MaximumLifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaximumLifetime);
                break;
              }
              case 26: {
                if (allowedIssuanceModes_ == null) {
                  AllowedIssuanceModes = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.IssuanceModes();
                }
                input.ReadMessage(AllowedIssuanceModes);
                break;
              }
              case 34: {
                if (baselineValues_ == null) {
                  BaselineValues = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
                }
                input.ReadMessage(BaselineValues);
                break;
              }
              case 42: {
                if (identityConstraints_ == null) {
                  IdentityConstraints = new global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints();
                }
                input.ReadMessage(IdentityConstraints);
                break;
              }
              case 50: {
                if (passthroughExtensions_ == null) {
                  PassthroughExtensions = new global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints();
                }
                input.ReadMessage(PassthroughExtensions);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the IssuancePolicy message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Describes a "type" of key that may be used in a [Certificate][google.cloud.security.privateca.v1.Certificate] issued
          /// from a [CaPool][google.cloud.security.privateca.v1.CaPool].
          /// Note that a single [AllowedKeyType][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType] may refer to either a
          /// fully-qualified key algorithm, such as RSA 4096, or a family of key
          /// algorithms, such as any RSA key.
          /// </summary>
          public sealed partial class AllowedKeyType : pb::IMessage<AllowedKeyType>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<AllowedKeyType> _parser = new pb::MessageParser<AllowedKeyType>(() => new AllowedKeyType());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<AllowedKeyType> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public AllowedKeyType() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public AllowedKeyType(AllowedKeyType other) : this() {
              switch (other.KeyTypeCase) {
                case KeyTypeOneofCase.Rsa:
                  Rsa = other.Rsa.Clone();
                  break;
                case KeyTypeOneofCase.EllipticCurve:
                  EllipticCurve = other.EllipticCurve.Clone();
                  break;
              }

              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public AllowedKeyType Clone() {
              return new AllowedKeyType(this);
            }

            /// <summary>Field number for the "rsa" field.</summary>
            public const int RsaFieldNumber = 1;
            /// <summary>
            /// Represents an allowed RSA key type.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.RsaKeyType Rsa {
              get { return keyTypeCase_ == KeyTypeOneofCase.Rsa ? (global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.RsaKeyType) keyType_ : null; }
              set {
                keyType_ = value;
                keyTypeCase_ = value == null ? KeyTypeOneofCase.None : KeyTypeOneofCase.Rsa;
              }
            }

            /// <summary>Field number for the "elliptic_curve" field.</summary>
            public const int EllipticCurveFieldNumber = 2;
            /// <summary>
            /// Represents an allowed Elliptic Curve key type.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType EllipticCurve {
              get { return keyTypeCase_ == KeyTypeOneofCase.EllipticCurve ? (global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType) keyType_ : null; }
              set {
                keyType_ = value;
                keyTypeCase_ = value == null ? KeyTypeOneofCase.None : KeyTypeOneofCase.EllipticCurve;
              }
            }

            private object keyType_;
            /// <summary>Enum of possible cases for the "key_type" oneof.</summary>
            public enum KeyTypeOneofCase {
              None = 0,
              Rsa = 1,
              EllipticCurve = 2,
            }
            private KeyTypeOneofCase keyTypeCase_ = KeyTypeOneofCase.None;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public KeyTypeOneofCase KeyTypeCase {
              get { return keyTypeCase_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void ClearKeyType() {
              keyTypeCase_ = KeyTypeOneofCase.None;
              keyType_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as AllowedKeyType);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(AllowedKeyType other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(Rsa, other.Rsa)) return false;
              if (!object.Equals(EllipticCurve, other.EllipticCurve)) return false;
              if (KeyTypeCase != other.KeyTypeCase) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (keyTypeCase_ == KeyTypeOneofCase.Rsa) hash ^= Rsa.GetHashCode();
              if (keyTypeCase_ == KeyTypeOneofCase.EllipticCurve) hash ^= EllipticCurve.GetHashCode();
              hash ^= (int) keyTypeCase_;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (keyTypeCase_ == KeyTypeOneofCase.Rsa) {
                output.WriteRawTag(10);
                output.WriteMessage(Rsa);
              }
              if (keyTypeCase_ == KeyTypeOneofCase.EllipticCurve) {
                output.WriteRawTag(18);
                output.WriteMessage(EllipticCurve);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (keyTypeCase_ == KeyTypeOneofCase.Rsa) {
                output.WriteRawTag(10);
                output.WriteMessage(Rsa);
              }
              if (keyTypeCase_ == KeyTypeOneofCase.EllipticCurve) {
                output.WriteRawTag(18);
                output.WriteMessage(EllipticCurve);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (keyTypeCase_ == KeyTypeOneofCase.Rsa) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rsa);
              }
              if (keyTypeCase_ == KeyTypeOneofCase.EllipticCurve) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(EllipticCurve);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(AllowedKeyType other) {
              if (other == null) {
                return;
              }
              switch (other.KeyTypeCase) {
                case KeyTypeOneofCase.Rsa:
                  if (Rsa == null) {
                    Rsa = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.RsaKeyType();
                  }
                  Rsa.MergeFrom(other.Rsa);
                  break;
                case KeyTypeOneofCase.EllipticCurve:
                  if (EllipticCurve == null) {
                    EllipticCurve = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType();
                  }
                  EllipticCurve.MergeFrom(other.EllipticCurve);
                  break;
              }

              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.RsaKeyType subBuilder = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.RsaKeyType();
                    if (keyTypeCase_ == KeyTypeOneofCase.Rsa) {
                      subBuilder.MergeFrom(Rsa);
                    }
                    input.ReadMessage(subBuilder);
                    Rsa = subBuilder;
                    break;
                  }
                  case 18: {
                    global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType subBuilder = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType();
                    if (keyTypeCase_ == KeyTypeOneofCase.EllipticCurve) {
                      subBuilder.MergeFrom(EllipticCurve);
                    }
                    input.ReadMessage(subBuilder);
                    EllipticCurve = subBuilder;
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.RsaKeyType subBuilder = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.RsaKeyType();
                    if (keyTypeCase_ == KeyTypeOneofCase.Rsa) {
                      subBuilder.MergeFrom(Rsa);
                    }
                    input.ReadMessage(subBuilder);
                    Rsa = subBuilder;
                    break;
                  }
                  case 18: {
                    global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType subBuilder = new global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType();
                    if (keyTypeCase_ == KeyTypeOneofCase.EllipticCurve) {
                      subBuilder.MergeFrom(EllipticCurve);
                    }
                    input.ReadMessage(subBuilder);
                    EllipticCurve = subBuilder;
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the AllowedKeyType message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static partial class Types {
              /// <summary>
              /// Describes an RSA key that may be used in a [Certificate][google.cloud.security.privateca.v1.Certificate] issued from
              /// a [CaPool][google.cloud.security.privateca.v1.CaPool].
              /// </summary>
              public sealed partial class RsaKeyType : pb::IMessage<RsaKeyType>
              #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  , pb::IBufferMessage
              #endif
              {
                private static readonly pb::MessageParser<RsaKeyType> _parser = new pb::MessageParser<RsaKeyType>(() => new RsaKeyType());
                private pb::UnknownFieldSet _unknownFields;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pb::MessageParser<RsaKeyType> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pbr::MessageDescriptor Descriptor {
                  get { return global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Descriptor.NestedTypes[0]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                pbr::MessageDescriptor pb::IMessage.Descriptor {
                  get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public RsaKeyType() {
                  OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public RsaKeyType(RsaKeyType other) : this() {
                  minModulusSize_ = other.minModulusSize_;
                  maxModulusSize_ = other.maxModulusSize_;
                  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public RsaKeyType Clone() {
                  return new RsaKeyType(this);
                }

                /// <summary>Field number for the "min_modulus_size" field.</summary>
                public const int MinModulusSizeFieldNumber = 1;
                private long minModulusSize_;
                /// <summary>
                /// Optional. The minimum allowed RSA modulus size, in bits. If this is not set,
                /// or if set to zero, the service-level min RSA modulus size will
                /// continue to apply.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public long MinModulusSize {
                  get { return minModulusSize_; }
                  set {
                    minModulusSize_ = value;
                  }
                }

                /// <summary>Field number for the "max_modulus_size" field.</summary>
                public const int MaxModulusSizeFieldNumber = 2;
                private long maxModulusSize_;
                /// <summary>
                /// Optional. The maximum allowed RSA modulus size, in bits. If this is not set,
                /// or if set to zero, the service will not enforce an explicit upper
                /// bound on RSA modulus sizes.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public long MaxModulusSize {
                  get { return maxModulusSize_; }
                  set {
                    maxModulusSize_ = value;
                  }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override bool Equals(object other) {
                  return Equals(other as RsaKeyType);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public bool Equals(RsaKeyType other) {
                  if (ReferenceEquals(other, null)) {
                    return false;
                  }
                  if (ReferenceEquals(other, this)) {
                    return true;
                  }
                  if (MinModulusSize != other.MinModulusSize) return false;
                  if (MaxModulusSize != other.MaxModulusSize) return false;
                  return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override int GetHashCode() {
                  int hash = 1;
                  if (MinModulusSize != 0L) hash ^= MinModulusSize.GetHashCode();
                  if (MaxModulusSize != 0L) hash ^= MaxModulusSize.GetHashCode();
                  if (_unknownFields != null) {
                    hash ^= _unknownFields.GetHashCode();
                  }
                  return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override string ToString() {
                  return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void WriteTo(pb::CodedOutputStream output) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  output.WriteRawMessage(this);
                #else
                  if (MinModulusSize != 0L) {
                    output.WriteRawTag(8);
                    output.WriteInt64(MinModulusSize);
                  }
                  if (MaxModulusSize != 0L) {
                    output.WriteRawTag(16);
                    output.WriteInt64(MaxModulusSize);
                  }
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(output);
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
                  if (MinModulusSize != 0L) {
                    output.WriteRawTag(8);
                    output.WriteInt64(MinModulusSize);
                  }
                  if (MaxModulusSize != 0L) {
                    output.WriteRawTag(16);
                    output.WriteInt64(MaxModulusSize);
                  }
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(ref output);
                  }
                }
                #endif

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public int CalculateSize() {
                  int size = 0;
                  if (MinModulusSize != 0L) {
                    size += 1 + pb::CodedOutputStream.ComputeInt64Size(MinModulusSize);
                  }
                  if (MaxModulusSize != 0L) {
                    size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxModulusSize);
                  }
                  if (_unknownFields != null) {
                    size += _unknownFields.CalculateSize();
                  }
                  return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(RsaKeyType other) {
                  if (other == null) {
                    return;
                  }
                  if (other.MinModulusSize != 0L) {
                    MinModulusSize = other.MinModulusSize;
                  }
                  if (other.MaxModulusSize != 0L) {
                    MaxModulusSize = other.MaxModulusSize;
                  }
                  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(pb::CodedInputStream input) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  input.ReadRawMessage(this);
                #else
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                      case 8: {
                        MinModulusSize = input.ReadInt64();
                        break;
                      }
                      case 16: {
                        MaxModulusSize = input.ReadInt64();
                        break;
                      }
                    }
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                      case 8: {
                        MinModulusSize = input.ReadInt64();
                        break;
                      }
                      case 16: {
                        MaxModulusSize = input.ReadInt64();
                        break;
                      }
                    }
                  }
                }
                #endif

              }

              /// <summary>
              /// Describes an Elliptic Curve key that may be used in a [Certificate][google.cloud.security.privateca.v1.Certificate]
              /// issued from a [CaPool][google.cloud.security.privateca.v1.CaPool].
              /// </summary>
              public sealed partial class EcKeyType : pb::IMessage<EcKeyType>
              #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  , pb::IBufferMessage
              #endif
              {
                private static readonly pb::MessageParser<EcKeyType> _parser = new pb::MessageParser<EcKeyType>(() => new EcKeyType());
                private pb::UnknownFieldSet _unknownFields;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pb::MessageParser<EcKeyType> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pbr::MessageDescriptor Descriptor {
                  get { return global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Descriptor.NestedTypes[1]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                pbr::MessageDescriptor pb::IMessage.Descriptor {
                  get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public EcKeyType() {
                  OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public EcKeyType(EcKeyType other) : this() {
                  signatureAlgorithm_ = other.signatureAlgorithm_;
                  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public EcKeyType Clone() {
                  return new EcKeyType(this);
                }

                /// <summary>Field number for the "signature_algorithm" field.</summary>
                public const int SignatureAlgorithmFieldNumber = 1;
                private global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm signatureAlgorithm_ = global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm.Unspecified;
                /// <summary>
                /// Optional. A signature algorithm that must be used. If this is omitted, any
                /// EC-based signature algorithm will be allowed.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm SignatureAlgorithm {
                  get { return signatureAlgorithm_; }
                  set {
                    signatureAlgorithm_ = value;
                  }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override bool Equals(object other) {
                  return Equals(other as EcKeyType);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public bool Equals(EcKeyType other) {
                  if (ReferenceEquals(other, null)) {
                    return false;
                  }
                  if (ReferenceEquals(other, this)) {
                    return true;
                  }
                  if (SignatureAlgorithm != other.SignatureAlgorithm) return false;
                  return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override int GetHashCode() {
                  int hash = 1;
                  if (SignatureAlgorithm != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm.Unspecified) hash ^= SignatureAlgorithm.GetHashCode();
                  if (_unknownFields != null) {
                    hash ^= _unknownFields.GetHashCode();
                  }
                  return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override string ToString() {
                  return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void WriteTo(pb::CodedOutputStream output) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  output.WriteRawMessage(this);
                #else
                  if (SignatureAlgorithm != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm.Unspecified) {
                    output.WriteRawTag(8);
                    output.WriteEnum((int) SignatureAlgorithm);
                  }
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(output);
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
                  if (SignatureAlgorithm != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm.Unspecified) {
                    output.WriteRawTag(8);
                    output.WriteEnum((int) SignatureAlgorithm);
                  }
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(ref output);
                  }
                }
                #endif

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public int CalculateSize() {
                  int size = 0;
                  if (SignatureAlgorithm != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm.Unspecified) {
                    size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SignatureAlgorithm);
                  }
                  if (_unknownFields != null) {
                    size += _unknownFields.CalculateSize();
                  }
                  return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(EcKeyType other) {
                  if (other == null) {
                    return;
                  }
                  if (other.SignatureAlgorithm != global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm.Unspecified) {
                    SignatureAlgorithm = other.SignatureAlgorithm;
                  }
                  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(pb::CodedInputStream input) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  input.ReadRawMessage(this);
                #else
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                      case 8: {
                        SignatureAlgorithm = (global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm) input.ReadEnum();
                        break;
                      }
                    }
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                      case 8: {
                        SignatureAlgorithm = (global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Types.AllowedKeyType.Types.EcKeyType.Types.EcSignatureAlgorithm) input.ReadEnum();
                        break;
                      }
                    }
                  }
                }
                #endif

                #region Nested types
                /// <summary>Container for nested types declared in the EcKeyType message type.</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static partial class Types {
                  /// <summary>
                  /// Describes an elliptic curve-based signature algorithm that may be
                  /// used in a [Certificate][google.cloud.security.privateca.v1.Certificate] issued from a [CaPool][google.cloud.security.privateca.v1.CaPool].
                  /// </summary>
                  public enum EcSignatureAlgorithm {
                    /// <summary>
                    /// Not specified. Signifies that any signature algorithm may be used.
                    /// </summary>
                    [pbr::OriginalName("EC_SIGNATURE_ALGORITHM_UNSPECIFIED")] Unspecified = 0,
                    /// <summary>
                    /// Refers to the Elliptic Curve Digital Signature Algorithm over the
                    /// NIST P-256 curve.
                    /// </summary>
                    [pbr::OriginalName("ECDSA_P256")] EcdsaP256 = 1,
                    /// <summary>
                    /// Refers to the Elliptic Curve Digital Signature Algorithm over the
                    /// NIST P-384 curve.
                    /// </summary>
                    [pbr::OriginalName("ECDSA_P384")] EcdsaP384 = 2,
                    /// <summary>
                    /// Refers to the Edwards-curve Digital Signature Algorithm over curve
                    /// 25519, as described in RFC 8410.
                    /// </summary>
                    [pbr::OriginalName("EDDSA_25519")] Eddsa25519 = 3,
                  }

                }
                #endregion

              }

            }
            #endregion

          }

          /// <summary>
          /// [IssuanceModes][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.IssuanceModes] specifies the allowed ways in which
          /// [Certificates][google.cloud.security.privateca.v1.Certificate] may be requested from this
          /// [CaPool][google.cloud.security.privateca.v1.CaPool].
          /// </summary>
          public sealed partial class IssuanceModes : pb::IMessage<IssuanceModes>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<IssuanceModes> _parser = new pb::MessageParser<IssuanceModes>(() => new IssuanceModes());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<IssuanceModes> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.Security.PrivateCA.V1.CaPool.Types.IssuancePolicy.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public IssuanceModes() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public IssuanceModes(IssuanceModes other) : this() {
              allowCsrBasedIssuance_ = other.allowCsrBasedIssuance_;
              allowConfigBasedIssuance_ = other.allowConfigBasedIssuance_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public IssuanceModes Clone() {
              return new IssuanceModes(this);
            }

            /// <summary>Field number for the "allow_csr_based_issuance" field.</summary>
            public const int AllowCsrBasedIssuanceFieldNumber = 1;
            private bool allowCsrBasedIssuance_;
            /// <summary>
            /// Required. When true, allows callers to create [Certificates][google.cloud.security.privateca.v1.Certificate] by
            /// specifying a CSR.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool AllowCsrBasedIssuance {
              get { return allowCsrBasedIssuance_; }
              set {
                allowCsrBasedIssuance_ = value;
              }
            }

            /// <summary>Field number for the "allow_config_based_issuance" field.</summary>
            public const int AllowConfigBasedIssuanceFieldNumber = 2;
            private bool allowConfigBasedIssuance_;
            /// <summary>
            /// Required. When true, allows callers to create [Certificates][google.cloud.security.privateca.v1.Certificate] by
            /// specifying a [CertificateConfig][google.cloud.security.privateca.v1.CertificateConfig].
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool AllowConfigBasedIssuance {
              get { return allowConfigBasedIssuance_; }
              set {
                allowConfigBasedIssuance_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as IssuanceModes);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(IssuanceModes other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (AllowCsrBasedIssuance != other.AllowCsrBasedIssuance) return false;
              if (AllowConfigBasedIssuance != other.AllowConfigBasedIssuance) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (AllowCsrBasedIssuance != false) hash ^= AllowCsrBasedIssuance.GetHashCode();
              if (AllowConfigBasedIssuance != false) hash ^= AllowConfigBasedIssuance.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (AllowCsrBasedIssuance != false) {
                output.WriteRawTag(8);
                output.WriteBool(AllowCsrBasedIssuance);
              }
              if (AllowConfigBasedIssuance != false) {
                output.WriteRawTag(16);
                output.WriteBool(AllowConfigBasedIssuance);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (AllowCsrBasedIssuance != false) {
                output.WriteRawTag(8);
                output.WriteBool(AllowCsrBasedIssuance);
              }
              if (AllowConfigBasedIssuance != false) {
                output.WriteRawTag(16);
                output.WriteBool(AllowConfigBasedIssuance);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (AllowCsrBasedIssuance != false) {
                size += 1 + 1;
              }
              if (AllowConfigBasedIssuance != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(IssuanceModes other) {
              if (other == null) {
                return;
              }
              if (other.AllowCsrBasedIssuance != false) {
                AllowCsrBasedIssuance = other.AllowCsrBasedIssuance;
              }
              if (other.AllowConfigBasedIssuance != false) {
                AllowConfigBasedIssuance = other.AllowConfigBasedIssuance;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    AllowCsrBasedIssuance = input.ReadBool();
                    break;
                  }
                  case 16: {
                    AllowConfigBasedIssuance = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    AllowCsrBasedIssuance = input.ReadBool();
                    break;
                  }
                  case 16: {
                    AllowConfigBasedIssuance = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// A [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList] corresponds to a signed X.509 certificate
  /// Revocation List (CRL). A CRL contains the serial numbers of certificates that
  /// should no longer be trusted.
  /// </summary>
  public sealed partial class CertificateRevocationList : pb::IMessage<CertificateRevocationList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateRevocationList> _parser = new pb::MessageParser<CertificateRevocationList>(() => new CertificateRevocationList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateRevocationList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateRevocationList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateRevocationList(CertificateRevocationList other) : this() {
      name_ = other.name_;
      sequenceNumber_ = other.sequenceNumber_;
      revokedCertificates_ = other.revokedCertificates_.Clone();
      pemCrl_ = other.pemCrl_;
      accessUrl_ = other.accessUrl_;
      state_ = other.state_;
      createTime_ = other.createTime_ != null ? other.createTime_.Clone() : null;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      revisionId_ = other.revisionId_;
      labels_ = other.labels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateRevocationList Clone() {
      return new CertificateRevocationList(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The resource name for this [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList] in
    /// the format
    /// `projects/*/locations/*/caPools/*certificateAuthorities/*/
    ///    certificateRevocationLists/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "sequence_number" field.</summary>
    public const int SequenceNumberFieldNumber = 2;
    private long sequenceNumber_;
    /// <summary>
    /// Output only. The CRL sequence number that appears in pem_crl.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long SequenceNumber {
      get { return sequenceNumber_; }
      set {
        sequenceNumber_ = value;
      }
    }

    /// <summary>Field number for the "revoked_certificates" field.</summary>
    public const int RevokedCertificatesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.RevokedCertificate> _repeated_revokedCertificates_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.RevokedCertificate.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.RevokedCertificate> revokedCertificates_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.RevokedCertificate>();
    /// <summary>
    /// Output only. The revoked serial numbers that appear in pem_crl.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.RevokedCertificate> RevokedCertificates {
      get { return revokedCertificates_; }
    }

    /// <summary>Field number for the "pem_crl" field.</summary>
    public const int PemCrlFieldNumber = 4;
    private string pemCrl_ = "";
    /// <summary>
    /// Output only. The PEM-encoded X.509 CRL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PemCrl {
      get { return pemCrl_; }
      set {
        pemCrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "access_url" field.</summary>
    public const int AccessUrlFieldNumber = 5;
    private string accessUrl_ = "";
    /// <summary>
    /// Output only. The location where 'pem_crl' can be accessed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AccessUrl {
      get { return accessUrl_; }
      set {
        accessUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 6;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State state_ = global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State.Unspecified;
    /// <summary>
    /// Output only. The [State][google.cloud.security.privateca.v1.CertificateRevocationList.State] for this [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    /// <summary>Field number for the "create_time" field.</summary>
    public const int CreateTimeFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Timestamp createTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList] was created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreateTime {
      get { return createTime_; }
      set {
        createTime_ = value;
      }
    }

    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList] was updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "revision_id" field.</summary>
    public const int RevisionIdFieldNumber = 9;
    private string revisionId_ = "";
    /// <summary>
    /// Output only. The revision ID of this [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]. A new revision is
    /// committed whenever a new CRL is published. The format is an 8-character
    /// hexadecimal string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RevisionId {
      get { return revisionId_; }
      set {
        revisionId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 10;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 82);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels with user-defined metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateRevocationList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateRevocationList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (SequenceNumber != other.SequenceNumber) return false;
      if(!revokedCertificates_.Equals(other.revokedCertificates_)) return false;
      if (PemCrl != other.PemCrl) return false;
      if (AccessUrl != other.AccessUrl) return false;
      if (State != other.State) return false;
      if (!object.Equals(CreateTime, other.CreateTime)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (RevisionId != other.RevisionId) return false;
      if (!Labels.Equals(other.Labels)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (SequenceNumber != 0L) hash ^= SequenceNumber.GetHashCode();
      hash ^= revokedCertificates_.GetHashCode();
      if (PemCrl.Length != 0) hash ^= PemCrl.GetHashCode();
      if (AccessUrl.Length != 0) hash ^= AccessUrl.GetHashCode();
      if (State != global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State.Unspecified) hash ^= State.GetHashCode();
      if (createTime_ != null) hash ^= CreateTime.GetHashCode();
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      if (RevisionId.Length != 0) hash ^= RevisionId.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (SequenceNumber != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(SequenceNumber);
      }
      revokedCertificates_.WriteTo(output, _repeated_revokedCertificates_codec);
      if (PemCrl.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(PemCrl);
      }
      if (AccessUrl.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(AccessUrl);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) State);
      }
      if (createTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(UpdateTime);
      }
      if (RevisionId.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(RevisionId);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (SequenceNumber != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(SequenceNumber);
      }
      revokedCertificates_.WriteTo(ref output, _repeated_revokedCertificates_codec);
      if (PemCrl.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(PemCrl);
      }
      if (AccessUrl.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(AccessUrl);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) State);
      }
      if (createTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(UpdateTime);
      }
      if (RevisionId.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(RevisionId);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (SequenceNumber != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SequenceNumber);
      }
      size += revokedCertificates_.CalculateSize(_repeated_revokedCertificates_codec);
      if (PemCrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PemCrl);
      }
      if (AccessUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AccessUrl);
      }
      if (State != global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      if (createTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreateTime);
      }
      if (updateTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      if (RevisionId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RevisionId);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateRevocationList other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.SequenceNumber != 0L) {
        SequenceNumber = other.SequenceNumber;
      }
      revokedCertificates_.Add(other.revokedCertificates_);
      if (other.PemCrl.Length != 0) {
        PemCrl = other.PemCrl;
      }
      if (other.AccessUrl.Length != 0) {
        AccessUrl = other.AccessUrl;
      }
      if (other.State != global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State.Unspecified) {
        State = other.State;
      }
      if (other.createTime_ != null) {
        if (createTime_ == null) {
          CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreateTime.MergeFrom(other.CreateTime);
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      if (other.RevisionId.Length != 0) {
        RevisionId = other.RevisionId;
      }
      labels_.Add(other.labels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            SequenceNumber = input.ReadInt64();
            break;
          }
          case 26: {
            revokedCertificates_.AddEntriesFrom(input, _repeated_revokedCertificates_codec);
            break;
          }
          case 34: {
            PemCrl = input.ReadString();
            break;
          }
          case 42: {
            AccessUrl = input.ReadString();
            break;
          }
          case 48: {
            State = (global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State) input.ReadEnum();
            break;
          }
          case 58: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 66: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 74: {
            RevisionId = input.ReadString();
            break;
          }
          case 82: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            SequenceNumber = input.ReadInt64();
            break;
          }
          case 26: {
            revokedCertificates_.AddEntriesFrom(ref input, _repeated_revokedCertificates_codec);
            break;
          }
          case 34: {
            PemCrl = input.ReadString();
            break;
          }
          case 42: {
            AccessUrl = input.ReadString();
            break;
          }
          case 48: {
            State = (global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Types.State) input.ReadEnum();
            break;
          }
          case 58: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 66: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 74: {
            RevisionId = input.ReadString();
            break;
          }
          case 82: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateRevocationList message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// The state of a [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList], indicating if it is current.
      /// </summary>
      public enum State {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("STATE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// The [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList] is up to date.
        /// </summary>
        [pbr::OriginalName("ACTIVE")] Active = 1,
        /// <summary>
        /// The [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList] is no longer current.
        /// </summary>
        [pbr::OriginalName("SUPERSEDED")] Superseded = 2,
      }

      /// <summary>
      /// Describes a revoked [Certificate][google.cloud.security.privateca.v1.Certificate].
      /// </summary>
      public sealed partial class RevokedCertificate : pb::IMessage<RevokedCertificate>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RevokedCertificate> _parser = new pb::MessageParser<RevokedCertificate>(() => new RevokedCertificate());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RevokedCertificate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.CertificateRevocationList.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevokedCertificate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevokedCertificate(RevokedCertificate other) : this() {
          certificate_ = other.certificate_;
          hexSerialNumber_ = other.hexSerialNumber_;
          revocationReason_ = other.revocationReason_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevokedCertificate Clone() {
          return new RevokedCertificate(this);
        }

        /// <summary>Field number for the "certificate" field.</summary>
        public const int CertificateFieldNumber = 1;
        private string certificate_ = "";
        /// <summary>
        /// The resource name for the [Certificate][google.cloud.security.privateca.v1.Certificate] in the format
        /// `projects/*/locations/*/caPools/*/certificates/*`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Certificate {
          get { return certificate_; }
          set {
            certificate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "hex_serial_number" field.</summary>
        public const int HexSerialNumberFieldNumber = 2;
        private string hexSerialNumber_ = "";
        /// <summary>
        /// The serial number of the [Certificate][google.cloud.security.privateca.v1.Certificate].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string HexSerialNumber {
          get { return hexSerialNumber_; }
          set {
            hexSerialNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "revocation_reason" field.</summary>
        public const int RevocationReasonFieldNumber = 3;
        private global::Google.Cloud.Security.PrivateCA.V1.RevocationReason revocationReason_ = global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified;
        /// <summary>
        /// The reason the [Certificate][google.cloud.security.privateca.v1.Certificate] was revoked.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.RevocationReason RevocationReason {
          get { return revocationReason_; }
          set {
            revocationReason_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RevokedCertificate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RevokedCertificate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Certificate != other.Certificate) return false;
          if (HexSerialNumber != other.HexSerialNumber) return false;
          if (RevocationReason != other.RevocationReason) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Certificate.Length != 0) hash ^= Certificate.GetHashCode();
          if (HexSerialNumber.Length != 0) hash ^= HexSerialNumber.GetHashCode();
          if (RevocationReason != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) hash ^= RevocationReason.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Certificate.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Certificate);
          }
          if (HexSerialNumber.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(HexSerialNumber);
          }
          if (RevocationReason != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) {
            output.WriteRawTag(24);
            output.WriteEnum((int) RevocationReason);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Certificate.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Certificate);
          }
          if (HexSerialNumber.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(HexSerialNumber);
          }
          if (RevocationReason != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) {
            output.WriteRawTag(24);
            output.WriteEnum((int) RevocationReason);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Certificate.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Certificate);
          }
          if (HexSerialNumber.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(HexSerialNumber);
          }
          if (RevocationReason != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RevocationReason);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RevokedCertificate other) {
          if (other == null) {
            return;
          }
          if (other.Certificate.Length != 0) {
            Certificate = other.Certificate;
          }
          if (other.HexSerialNumber.Length != 0) {
            HexSerialNumber = other.HexSerialNumber;
          }
          if (other.RevocationReason != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) {
            RevocationReason = other.RevocationReason;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Certificate = input.ReadString();
                break;
              }
              case 18: {
                HexSerialNumber = input.ReadString();
                break;
              }
              case 24: {
                RevocationReason = (global::Google.Cloud.Security.PrivateCA.V1.RevocationReason) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Certificate = input.ReadString();
                break;
              }
              case 18: {
                HexSerialNumber = input.ReadString();
                break;
              }
              case 24: {
                RevocationReason = (global::Google.Cloud.Security.PrivateCA.V1.RevocationReason) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [Certificate][google.cloud.security.privateca.v1.Certificate] corresponds to a signed X.509 certificate issued by a
  /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
  /// </summary>
  public sealed partial class Certificate : pb::IMessage<Certificate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Certificate> _parser = new pb::MessageParser<Certificate>(() => new Certificate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Certificate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Certificate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Certificate(Certificate other) : this() {
      name_ = other.name_;
      issuerCertificateAuthority_ = other.issuerCertificateAuthority_;
      lifetime_ = other.lifetime_ != null ? other.lifetime_.Clone() : null;
      certificateTemplate_ = other.certificateTemplate_;
      subjectMode_ = other.subjectMode_;
      revocationDetails_ = other.revocationDetails_ != null ? other.revocationDetails_.Clone() : null;
      pemCertificate_ = other.pemCertificate_;
      certificateDescription_ = other.certificateDescription_ != null ? other.certificateDescription_.Clone() : null;
      pemCertificateChain_ = other.pemCertificateChain_.Clone();
      createTime_ = other.createTime_ != null ? other.createTime_.Clone() : null;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      labels_ = other.labels_.Clone();
      switch (other.CertificateConfigCase) {
        case CertificateConfigOneofCase.PemCsr:
          PemCsr = other.PemCsr;
          break;
        case CertificateConfigOneofCase.Config:
          Config = other.Config.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Certificate Clone() {
      return new Certificate(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The resource name for this [Certificate][google.cloud.security.privateca.v1.Certificate] in the format
    /// `projects/*/locations/*/caPools/*/certificates/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "pem_csr" field.</summary>
    public const int PemCsrFieldNumber = 2;
    /// <summary>
    /// Immutable. A pem-encoded X.509 certificate signing request (CSR).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PemCsr {
      get { return certificateConfigCase_ == CertificateConfigOneofCase.PemCsr ? (string) certificateConfig_ : ""; }
      set {
        certificateConfig_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        certificateConfigCase_ = CertificateConfigOneofCase.PemCsr;
      }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 3;
    /// <summary>
    /// Immutable. A description of the certificate and key that does not require X.509 or
    /// ASN.1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig Config {
      get { return certificateConfigCase_ == CertificateConfigOneofCase.Config ? (global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig) certificateConfig_ : null; }
      set {
        certificateConfig_ = value;
        certificateConfigCase_ = value == null ? CertificateConfigOneofCase.None : CertificateConfigOneofCase.Config;
      }
    }

    /// <summary>Field number for the "issuer_certificate_authority" field.</summary>
    public const int IssuerCertificateAuthorityFieldNumber = 4;
    private string issuerCertificateAuthority_ = "";
    /// <summary>
    /// Output only. The resource name of the issuing [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] in the format
    /// `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string IssuerCertificateAuthority {
      get { return issuerCertificateAuthority_; }
      set {
        issuerCertificateAuthority_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "lifetime" field.</summary>
    public const int LifetimeFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Duration lifetime_;
    /// <summary>
    /// Required. Immutable. The desired lifetime of a certificate. Used to create the
    /// "not_before_time" and "not_after_time" fields inside an X.509
    /// certificate. Note that the lifetime may be truncated if it would extend
    /// past the life of any certificate authority in the issuing chain.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Lifetime {
      get { return lifetime_; }
      set {
        lifetime_ = value;
      }
    }

    /// <summary>Field number for the "certificate_template" field.</summary>
    public const int CertificateTemplateFieldNumber = 6;
    private string certificateTemplate_ = "";
    /// <summary>
    /// Immutable. The resource name for a [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate] used to issue this
    /// certificate, in the format
    /// `projects/*/locations/*/certificateTemplates/*`.
    /// If this is specified, the caller must have the necessary permission to
    /// use this template. If this is omitted, no template will be used.
    /// This template must be in the same location as the [Certificate][google.cloud.security.privateca.v1.Certificate].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CertificateTemplate {
      get { return certificateTemplate_; }
      set {
        certificateTemplate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "subject_mode" field.</summary>
    public const int SubjectModeFieldNumber = 7;
    private global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode subjectMode_ = global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode.Unspecified;
    /// <summary>
    /// Immutable. Specifies how the [Certificate][google.cloud.security.privateca.v1.Certificate]'s identity fields are to be decided.
    /// If this is omitted, the `DEFAULT` subject mode will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode SubjectMode {
      get { return subjectMode_; }
      set {
        subjectMode_ = value;
      }
    }

    /// <summary>Field number for the "revocation_details" field.</summary>
    public const int RevocationDetailsFieldNumber = 8;
    private global::Google.Cloud.Security.PrivateCA.V1.Certificate.Types.RevocationDetails revocationDetails_;
    /// <summary>
    /// Output only. Details regarding the revocation of this [Certificate][google.cloud.security.privateca.v1.Certificate]. This
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] is considered revoked if and only if this field is present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.Certificate.Types.RevocationDetails RevocationDetails {
      get { return revocationDetails_; }
      set {
        revocationDetails_ = value;
      }
    }

    /// <summary>Field number for the "pem_certificate" field.</summary>
    public const int PemCertificateFieldNumber = 9;
    private string pemCertificate_ = "";
    /// <summary>
    /// Output only. The pem-encoded, signed X.509 certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PemCertificate {
      get { return pemCertificate_; }
      set {
        pemCertificate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "certificate_description" field.</summary>
    public const int CertificateDescriptionFieldNumber = 10;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription certificateDescription_;
    /// <summary>
    /// Output only. A structured description of the issued X.509 certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription CertificateDescription {
      get { return certificateDescription_; }
      set {
        certificateDescription_ = value;
      }
    }

    /// <summary>Field number for the "pem_certificate_chain" field.</summary>
    public const int PemCertificateChainFieldNumber = 11;
    private static readonly pb::FieldCodec<string> _repeated_pemCertificateChain_codec
        = pb::FieldCodec.ForString(90);
    private readonly pbc::RepeatedField<string> pemCertificateChain_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Output only. The chain that may be used to verify the X.509 certificate. Expected to be
    /// in issuer-to-root order according to RFC 5246.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> PemCertificateChain {
      get { return pemCertificateChain_; }
    }

    /// <summary>Field number for the "create_time" field.</summary>
    public const int CreateTimeFieldNumber = 12;
    private global::Google.Protobuf.WellKnownTypes.Timestamp createTime_;
    /// <summary>
    /// Output only. The time at which this [Certificate][google.cloud.security.privateca.v1.Certificate] was created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreateTime {
      get { return createTime_; }
      set {
        createTime_ = value;
      }
    }

    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 13;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// Output only. The time at which this [Certificate][google.cloud.security.privateca.v1.Certificate] was updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 14;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 114);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels with user-defined metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    private object certificateConfig_;
    /// <summary>Enum of possible cases for the "certificate_config" oneof.</summary>
    public enum CertificateConfigOneofCase {
      None = 0,
      PemCsr = 2,
      Config = 3,
    }
    private CertificateConfigOneofCase certificateConfigCase_ = CertificateConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateConfigOneofCase CertificateConfigCase {
      get { return certificateConfigCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCertificateConfig() {
      certificateConfigCase_ = CertificateConfigOneofCase.None;
      certificateConfig_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Certificate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Certificate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (PemCsr != other.PemCsr) return false;
      if (!object.Equals(Config, other.Config)) return false;
      if (IssuerCertificateAuthority != other.IssuerCertificateAuthority) return false;
      if (!object.Equals(Lifetime, other.Lifetime)) return false;
      if (CertificateTemplate != other.CertificateTemplate) return false;
      if (SubjectMode != other.SubjectMode) return false;
      if (!object.Equals(RevocationDetails, other.RevocationDetails)) return false;
      if (PemCertificate != other.PemCertificate) return false;
      if (!object.Equals(CertificateDescription, other.CertificateDescription)) return false;
      if(!pemCertificateChain_.Equals(other.pemCertificateChain_)) return false;
      if (!object.Equals(CreateTime, other.CreateTime)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      if (CertificateConfigCase != other.CertificateConfigCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (certificateConfigCase_ == CertificateConfigOneofCase.PemCsr) hash ^= PemCsr.GetHashCode();
      if (certificateConfigCase_ == CertificateConfigOneofCase.Config) hash ^= Config.GetHashCode();
      if (IssuerCertificateAuthority.Length != 0) hash ^= IssuerCertificateAuthority.GetHashCode();
      if (lifetime_ != null) hash ^= Lifetime.GetHashCode();
      if (CertificateTemplate.Length != 0) hash ^= CertificateTemplate.GetHashCode();
      if (SubjectMode != global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode.Unspecified) hash ^= SubjectMode.GetHashCode();
      if (revocationDetails_ != null) hash ^= RevocationDetails.GetHashCode();
      if (PemCertificate.Length != 0) hash ^= PemCertificate.GetHashCode();
      if (certificateDescription_ != null) hash ^= CertificateDescription.GetHashCode();
      hash ^= pemCertificateChain_.GetHashCode();
      if (createTime_ != null) hash ^= CreateTime.GetHashCode();
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      hash ^= Labels.GetHashCode();
      hash ^= (int) certificateConfigCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.PemCsr) {
        output.WriteRawTag(18);
        output.WriteString(PemCsr);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
        output.WriteRawTag(26);
        output.WriteMessage(Config);
      }
      if (IssuerCertificateAuthority.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(IssuerCertificateAuthority);
      }
      if (lifetime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Lifetime);
      }
      if (CertificateTemplate.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(CertificateTemplate);
      }
      if (SubjectMode != global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode.Unspecified) {
        output.WriteRawTag(56);
        output.WriteEnum((int) SubjectMode);
      }
      if (revocationDetails_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(RevocationDetails);
      }
      if (PemCertificate.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(PemCertificate);
      }
      if (certificateDescription_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CertificateDescription);
      }
      pemCertificateChain_.WriteTo(output, _repeated_pemCertificateChain_codec);
      if (createTime_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.PemCsr) {
        output.WriteRawTag(18);
        output.WriteString(PemCsr);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
        output.WriteRawTag(26);
        output.WriteMessage(Config);
      }
      if (IssuerCertificateAuthority.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(IssuerCertificateAuthority);
      }
      if (lifetime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Lifetime);
      }
      if (CertificateTemplate.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(CertificateTemplate);
      }
      if (SubjectMode != global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode.Unspecified) {
        output.WriteRawTag(56);
        output.WriteEnum((int) SubjectMode);
      }
      if (revocationDetails_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(RevocationDetails);
      }
      if (PemCertificate.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(PemCertificate);
      }
      if (certificateDescription_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CertificateDescription);
      }
      pemCertificateChain_.WriteTo(ref output, _repeated_pemCertificateChain_codec);
      if (createTime_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.PemCsr) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PemCsr);
      }
      if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (IssuerCertificateAuthority.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IssuerCertificateAuthority);
      }
      if (lifetime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lifetime);
      }
      if (CertificateTemplate.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CertificateTemplate);
      }
      if (SubjectMode != global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SubjectMode);
      }
      if (revocationDetails_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RevocationDetails);
      }
      if (PemCertificate.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PemCertificate);
      }
      if (certificateDescription_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CertificateDescription);
      }
      size += pemCertificateChain_.CalculateSize(_repeated_pemCertificateChain_codec);
      if (createTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreateTime);
      }
      if (updateTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Certificate other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.IssuerCertificateAuthority.Length != 0) {
        IssuerCertificateAuthority = other.IssuerCertificateAuthority;
      }
      if (other.lifetime_ != null) {
        if (lifetime_ == null) {
          Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Lifetime.MergeFrom(other.Lifetime);
      }
      if (other.CertificateTemplate.Length != 0) {
        CertificateTemplate = other.CertificateTemplate;
      }
      if (other.SubjectMode != global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode.Unspecified) {
        SubjectMode = other.SubjectMode;
      }
      if (other.revocationDetails_ != null) {
        if (revocationDetails_ == null) {
          RevocationDetails = new global::Google.Cloud.Security.PrivateCA.V1.Certificate.Types.RevocationDetails();
        }
        RevocationDetails.MergeFrom(other.RevocationDetails);
      }
      if (other.PemCertificate.Length != 0) {
        PemCertificate = other.PemCertificate;
      }
      if (other.certificateDescription_ != null) {
        if (certificateDescription_ == null) {
          CertificateDescription = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription();
        }
        CertificateDescription.MergeFrom(other.CertificateDescription);
      }
      pemCertificateChain_.Add(other.pemCertificateChain_);
      if (other.createTime_ != null) {
        if (createTime_ == null) {
          CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreateTime.MergeFrom(other.CreateTime);
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      labels_.Add(other.labels_);
      switch (other.CertificateConfigCase) {
        case CertificateConfigOneofCase.PemCsr:
          PemCsr = other.PemCsr;
          break;
        case CertificateConfigOneofCase.Config:
          if (Config == null) {
            Config = new global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig();
          }
          Config.MergeFrom(other.Config);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            PemCsr = input.ReadString();
            break;
          }
          case 26: {
            global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig subBuilder = new global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig();
            if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
              subBuilder.MergeFrom(Config);
            }
            input.ReadMessage(subBuilder);
            Config = subBuilder;
            break;
          }
          case 34: {
            IssuerCertificateAuthority = input.ReadString();
            break;
          }
          case 42: {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lifetime);
            break;
          }
          case 50: {
            CertificateTemplate = input.ReadString();
            break;
          }
          case 56: {
            SubjectMode = (global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode) input.ReadEnum();
            break;
          }
          case 66: {
            if (revocationDetails_ == null) {
              RevocationDetails = new global::Google.Cloud.Security.PrivateCA.V1.Certificate.Types.RevocationDetails();
            }
            input.ReadMessage(RevocationDetails);
            break;
          }
          case 74: {
            PemCertificate = input.ReadString();
            break;
          }
          case 82: {
            if (certificateDescription_ == null) {
              CertificateDescription = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription();
            }
            input.ReadMessage(CertificateDescription);
            break;
          }
          case 90: {
            pemCertificateChain_.AddEntriesFrom(input, _repeated_pemCertificateChain_codec);
            break;
          }
          case 98: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 106: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 114: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            PemCsr = input.ReadString();
            break;
          }
          case 26: {
            global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig subBuilder = new global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig();
            if (certificateConfigCase_ == CertificateConfigOneofCase.Config) {
              subBuilder.MergeFrom(Config);
            }
            input.ReadMessage(subBuilder);
            Config = subBuilder;
            break;
          }
          case 34: {
            IssuerCertificateAuthority = input.ReadString();
            break;
          }
          case 42: {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Lifetime);
            break;
          }
          case 50: {
            CertificateTemplate = input.ReadString();
            break;
          }
          case 56: {
            SubjectMode = (global::Google.Cloud.Security.PrivateCA.V1.SubjectRequestMode) input.ReadEnum();
            break;
          }
          case 66: {
            if (revocationDetails_ == null) {
              RevocationDetails = new global::Google.Cloud.Security.PrivateCA.V1.Certificate.Types.RevocationDetails();
            }
            input.ReadMessage(RevocationDetails);
            break;
          }
          case 74: {
            PemCertificate = input.ReadString();
            break;
          }
          case 82: {
            if (certificateDescription_ == null) {
              CertificateDescription = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription();
            }
            input.ReadMessage(CertificateDescription);
            break;
          }
          case 90: {
            pemCertificateChain_.AddEntriesFrom(ref input, _repeated_pemCertificateChain_codec);
            break;
          }
          case 98: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 106: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 114: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Certificate message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Describes fields that are relavent to the revocation of a [Certificate][google.cloud.security.privateca.v1.Certificate].
      /// </summary>
      public sealed partial class RevocationDetails : pb::IMessage<RevocationDetails>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RevocationDetails> _parser = new pb::MessageParser<RevocationDetails>(() => new RevocationDetails());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RevocationDetails> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.Certificate.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevocationDetails() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevocationDetails(RevocationDetails other) : this() {
          revocationState_ = other.revocationState_;
          revocationTime_ = other.revocationTime_ != null ? other.revocationTime_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RevocationDetails Clone() {
          return new RevocationDetails(this);
        }

        /// <summary>Field number for the "revocation_state" field.</summary>
        public const int RevocationStateFieldNumber = 1;
        private global::Google.Cloud.Security.PrivateCA.V1.RevocationReason revocationState_ = global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified;
        /// <summary>
        /// Indicates why a [Certificate][google.cloud.security.privateca.v1.Certificate] was revoked.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.RevocationReason RevocationState {
          get { return revocationState_; }
          set {
            revocationState_ = value;
          }
        }

        /// <summary>Field number for the "revocation_time" field.</summary>
        public const int RevocationTimeFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Timestamp revocationTime_;
        /// <summary>
        /// The time at which this [Certificate][google.cloud.security.privateca.v1.Certificate] was revoked.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp RevocationTime {
          get { return revocationTime_; }
          set {
            revocationTime_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RevocationDetails);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RevocationDetails other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (RevocationState != other.RevocationState) return false;
          if (!object.Equals(RevocationTime, other.RevocationTime)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (RevocationState != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) hash ^= RevocationState.GetHashCode();
          if (revocationTime_ != null) hash ^= RevocationTime.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (RevocationState != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) RevocationState);
          }
          if (revocationTime_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(RevocationTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (RevocationState != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) RevocationState);
          }
          if (revocationTime_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(RevocationTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (RevocationState != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RevocationState);
          }
          if (revocationTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RevocationTime);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RevocationDetails other) {
          if (other == null) {
            return;
          }
          if (other.RevocationState != global::Google.Cloud.Security.PrivateCA.V1.RevocationReason.Unspecified) {
            RevocationState = other.RevocationState;
          }
          if (other.revocationTime_ != null) {
            if (revocationTime_ == null) {
              RevocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            RevocationTime.MergeFrom(other.RevocationTime);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                RevocationState = (global::Google.Cloud.Security.PrivateCA.V1.RevocationReason) input.ReadEnum();
                break;
              }
              case 18: {
                if (revocationTime_ == null) {
                  RevocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(RevocationTime);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                RevocationState = (global::Google.Cloud.Security.PrivateCA.V1.RevocationReason) input.ReadEnum();
                break;
              }
              case 18: {
                if (revocationTime_ == null) {
                  RevocationTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(RevocationTime);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate] refers to a managed template for certificate
  /// issuance.
  /// </summary>
  public sealed partial class CertificateTemplate : pb::IMessage<CertificateTemplate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateTemplate> _parser = new pb::MessageParser<CertificateTemplate>(() => new CertificateTemplate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateTemplate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateTemplate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateTemplate(CertificateTemplate other) : this() {
      name_ = other.name_;
      predefinedValues_ = other.predefinedValues_ != null ? other.predefinedValues_.Clone() : null;
      identityConstraints_ = other.identityConstraints_ != null ? other.identityConstraints_.Clone() : null;
      passthroughExtensions_ = other.passthroughExtensions_ != null ? other.passthroughExtensions_.Clone() : null;
      description_ = other.description_;
      createTime_ = other.createTime_ != null ? other.createTime_.Clone() : null;
      updateTime_ = other.updateTime_ != null ? other.updateTime_.Clone() : null;
      labels_ = other.labels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateTemplate Clone() {
      return new CertificateTemplate(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The resource name for this [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate] in the format
    /// `projects/*/locations/*/certificateTemplates/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "predefined_values" field.</summary>
    public const int PredefinedValuesFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1.X509Parameters predefinedValues_;
    /// <summary>
    /// Optional. A set of X.509 values that will be applied to all issued certificates that
    /// use this template. If the certificate request includes conflicting values
    /// for the same properties, they will be overwritten by the values defined
    /// here. If the issuing [CaPool][google.cloud.security.privateca.v1.CaPool]'s [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy]
    /// defines conflicting
    /// [baseline_values][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values] for the same
    /// properties, the certificate issuance request will fail.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.X509Parameters PredefinedValues {
      get { return predefinedValues_; }
      set {
        predefinedValues_ = value;
      }
    }

    /// <summary>Field number for the "identity_constraints" field.</summary>
    public const int IdentityConstraintsFieldNumber = 3;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints identityConstraints_;
    /// <summary>
    /// Optional. Describes constraints on identities that may be appear in
    /// [Certificates][google.cloud.security.privateca.v1.Certificate] issued using this template. If this is omitted,
    /// then this template will not add restrictions on a certificate's identity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints IdentityConstraints {
      get { return identityConstraints_; }
      set {
        identityConstraints_ = value;
      }
    }

    /// <summary>Field number for the "passthrough_extensions" field.</summary>
    public const int PassthroughExtensionsFieldNumber = 4;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints passthroughExtensions_;
    /// <summary>
    /// Optional. Describes the set of X.509 extensions that may appear in a
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] issued using this [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]. If a certificate
    /// request sets extensions that don't appear in the
    /// [passthrough_extensions][google.cloud.security.privateca.v1.CertificateTemplate.passthrough_extensions], those extensions will be dropped. If the
    /// issuing [CaPool][google.cloud.security.privateca.v1.CaPool]'s [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy] defines
    /// [baseline_values][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values] that don't appear
    /// here, the certificate issuance request will fail. If this is omitted, then
    /// this template will not add restrictions on a certificate's X.509
    /// extensions. These constraints do not apply to X.509 extensions set in this
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]'s [predefined_values][google.cloud.security.privateca.v1.CertificateTemplate.predefined_values].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints PassthroughExtensions {
      get { return passthroughExtensions_; }
      set {
        passthroughExtensions_ = value;
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 5;
    private string description_ = "";
    /// <summary>
    /// Optional. A human-readable description of scenarios this template is intended for.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "create_time" field.</summary>
    public const int CreateTimeFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Timestamp createTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate] was created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CreateTime {
      get { return createTime_; }
      set {
        createTime_ = value;
      }
    }

    /// <summary>Field number for the "update_time" field.</summary>
    public const int UpdateTimeFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Timestamp updateTime_;
    /// <summary>
    /// Output only. The time at which this [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate] was updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp UpdateTime {
      get { return updateTime_; }
      set {
        updateTime_ = value;
      }
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 8;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 66);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels with user-defined metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateTemplate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateTemplate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(PredefinedValues, other.PredefinedValues)) return false;
      if (!object.Equals(IdentityConstraints, other.IdentityConstraints)) return false;
      if (!object.Equals(PassthroughExtensions, other.PassthroughExtensions)) return false;
      if (Description != other.Description) return false;
      if (!object.Equals(CreateTime, other.CreateTime)) return false;
      if (!object.Equals(UpdateTime, other.UpdateTime)) return false;
      if (!Labels.Equals(other.Labels)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (predefinedValues_ != null) hash ^= PredefinedValues.GetHashCode();
      if (identityConstraints_ != null) hash ^= IdentityConstraints.GetHashCode();
      if (passthroughExtensions_ != null) hash ^= PassthroughExtensions.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (createTime_ != null) hash ^= CreateTime.GetHashCode();
      if (updateTime_ != null) hash ^= UpdateTime.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (predefinedValues_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PredefinedValues);
      }
      if (identityConstraints_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IdentityConstraints);
      }
      if (passthroughExtensions_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PassthroughExtensions);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Description);
      }
      if (createTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (predefinedValues_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PredefinedValues);
      }
      if (identityConstraints_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IdentityConstraints);
      }
      if (passthroughExtensions_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PassthroughExtensions);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Description);
      }
      if (createTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(CreateTime);
      }
      if (updateTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(UpdateTime);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (predefinedValues_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PredefinedValues);
      }
      if (identityConstraints_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IdentityConstraints);
      }
      if (passthroughExtensions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PassthroughExtensions);
      }
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (createTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CreateTime);
      }
      if (updateTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateTime);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateTemplate other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.predefinedValues_ != null) {
        if (predefinedValues_ == null) {
          PredefinedValues = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
        }
        PredefinedValues.MergeFrom(other.PredefinedValues);
      }
      if (other.identityConstraints_ != null) {
        if (identityConstraints_ == null) {
          IdentityConstraints = new global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints();
        }
        IdentityConstraints.MergeFrom(other.IdentityConstraints);
      }
      if (other.passthroughExtensions_ != null) {
        if (passthroughExtensions_ == null) {
          PassthroughExtensions = new global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints();
        }
        PassthroughExtensions.MergeFrom(other.PassthroughExtensions);
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.createTime_ != null) {
        if (createTime_ == null) {
          CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CreateTime.MergeFrom(other.CreateTime);
      }
      if (other.updateTime_ != null) {
        if (updateTime_ == null) {
          UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        UpdateTime.MergeFrom(other.UpdateTime);
      }
      labels_.Add(other.labels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (predefinedValues_ == null) {
              PredefinedValues = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
            }
            input.ReadMessage(PredefinedValues);
            break;
          }
          case 26: {
            if (identityConstraints_ == null) {
              IdentityConstraints = new global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints();
            }
            input.ReadMessage(IdentityConstraints);
            break;
          }
          case 34: {
            if (passthroughExtensions_ == null) {
              PassthroughExtensions = new global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints();
            }
            input.ReadMessage(PassthroughExtensions);
            break;
          }
          case 42: {
            Description = input.ReadString();
            break;
          }
          case 50: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 58: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 66: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (predefinedValues_ == null) {
              PredefinedValues = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
            }
            input.ReadMessage(PredefinedValues);
            break;
          }
          case 26: {
            if (identityConstraints_ == null) {
              IdentityConstraints = new global::Google.Cloud.Security.PrivateCA.V1.CertificateIdentityConstraints();
            }
            input.ReadMessage(IdentityConstraints);
            break;
          }
          case 34: {
            if (passthroughExtensions_ == null) {
              PassthroughExtensions = new global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints();
            }
            input.ReadMessage(PassthroughExtensions);
            break;
          }
          case 42: {
            Description = input.ReadString();
            break;
          }
          case 50: {
            if (createTime_ == null) {
              CreateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CreateTime);
            break;
          }
          case 58: {
            if (updateTime_ == null) {
              UpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(UpdateTime);
            break;
          }
          case 66: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// An [X509Parameters][google.cloud.security.privateca.v1.X509Parameters] is used to describe certain fields of an
  /// X.509 certificate, such as the key usage fields, fields specific to CA
  /// certificates, certificate policy extensions and custom extensions.
  /// </summary>
  public sealed partial class X509Parameters : pb::IMessage<X509Parameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<X509Parameters> _parser = new pb::MessageParser<X509Parameters>(() => new X509Parameters());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<X509Parameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public X509Parameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public X509Parameters(X509Parameters other) : this() {
      keyUsage_ = other.keyUsage_ != null ? other.keyUsage_.Clone() : null;
      caOptions_ = other.caOptions_ != null ? other.caOptions_.Clone() : null;
      policyIds_ = other.policyIds_.Clone();
      aiaOcspServers_ = other.aiaOcspServers_.Clone();
      additionalExtensions_ = other.additionalExtensions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public X509Parameters Clone() {
      return new X509Parameters(this);
    }

    /// <summary>Field number for the "key_usage" field.</summary>
    public const int KeyUsageFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1.KeyUsage keyUsage_;
    /// <summary>
    /// Optional. Indicates the intended use for keys that correspond to a certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.KeyUsage KeyUsage {
      get { return keyUsage_; }
      set {
        keyUsage_ = value;
      }
    }

    /// <summary>Field number for the "ca_options" field.</summary>
    public const int CaOptionsFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1.X509Parameters.Types.CaOptions caOptions_;
    /// <summary>
    /// Optional. Describes options in this [X509Parameters][google.cloud.security.privateca.v1.X509Parameters] that are relevant in a CA
    /// certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.X509Parameters.Types.CaOptions CaOptions {
      get { return caOptions_; }
      set {
        caOptions_ = value;
      }
    }

    /// <summary>Field number for the "policy_ids" field.</summary>
    public const int PolicyIdsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1.ObjectId> _repeated_policyIds_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Cloud.Security.PrivateCA.V1.ObjectId.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.ObjectId> policyIds_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.ObjectId>();
    /// <summary>
    /// Optional. Describes the X.509 certificate policy object identifiers, per
    /// https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.ObjectId> PolicyIds {
      get { return policyIds_; }
    }

    /// <summary>Field number for the "aia_ocsp_servers" field.</summary>
    public const int AiaOcspServersFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_aiaOcspServers_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> aiaOcspServers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses
    /// that appear in the "Authority Information Access" extension in the
    /// certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> AiaOcspServers {
      get { return aiaOcspServers_; }
    }

    /// <summary>Field number for the "additional_extensions" field.</summary>
    public const int AdditionalExtensionsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1.X509Extension> _repeated_additionalExtensions_codec
        = pb::FieldCodec.ForMessage(42, global::Google.Cloud.Security.PrivateCA.V1.X509Extension.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.X509Extension> additionalExtensions_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.X509Extension>();
    /// <summary>
    /// Optional. Describes custom X.509 extensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.X509Extension> AdditionalExtensions {
      get { return additionalExtensions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as X509Parameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(X509Parameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(KeyUsage, other.KeyUsage)) return false;
      if (!object.Equals(CaOptions, other.CaOptions)) return false;
      if(!policyIds_.Equals(other.policyIds_)) return false;
      if(!aiaOcspServers_.Equals(other.aiaOcspServers_)) return false;
      if(!additionalExtensions_.Equals(other.additionalExtensions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (keyUsage_ != null) hash ^= KeyUsage.GetHashCode();
      if (caOptions_ != null) hash ^= CaOptions.GetHashCode();
      hash ^= policyIds_.GetHashCode();
      hash ^= aiaOcspServers_.GetHashCode();
      hash ^= additionalExtensions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (keyUsage_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(KeyUsage);
      }
      if (caOptions_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(CaOptions);
      }
      policyIds_.WriteTo(output, _repeated_policyIds_codec);
      aiaOcspServers_.WriteTo(output, _repeated_aiaOcspServers_codec);
      additionalExtensions_.WriteTo(output, _repeated_additionalExtensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (keyUsage_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(KeyUsage);
      }
      if (caOptions_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(CaOptions);
      }
      policyIds_.WriteTo(ref output, _repeated_policyIds_codec);
      aiaOcspServers_.WriteTo(ref output, _repeated_aiaOcspServers_codec);
      additionalExtensions_.WriteTo(ref output, _repeated_additionalExtensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (keyUsage_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyUsage);
      }
      if (caOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CaOptions);
      }
      size += policyIds_.CalculateSize(_repeated_policyIds_codec);
      size += aiaOcspServers_.CalculateSize(_repeated_aiaOcspServers_codec);
      size += additionalExtensions_.CalculateSize(_repeated_additionalExtensions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(X509Parameters other) {
      if (other == null) {
        return;
      }
      if (other.keyUsage_ != null) {
        if (keyUsage_ == null) {
          KeyUsage = new global::Google.Cloud.Security.PrivateCA.V1.KeyUsage();
        }
        KeyUsage.MergeFrom(other.KeyUsage);
      }
      if (other.caOptions_ != null) {
        if (caOptions_ == null) {
          CaOptions = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters.Types.CaOptions();
        }
        CaOptions.MergeFrom(other.CaOptions);
      }
      policyIds_.Add(other.policyIds_);
      aiaOcspServers_.Add(other.aiaOcspServers_);
      additionalExtensions_.Add(other.additionalExtensions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (keyUsage_ == null) {
              KeyUsage = new global::Google.Cloud.Security.PrivateCA.V1.KeyUsage();
            }
            input.ReadMessage(KeyUsage);
            break;
          }
          case 18: {
            if (caOptions_ == null) {
              CaOptions = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters.Types.CaOptions();
            }
            input.ReadMessage(CaOptions);
            break;
          }
          case 26: {
            policyIds_.AddEntriesFrom(input, _repeated_policyIds_codec);
            break;
          }
          case 34: {
            aiaOcspServers_.AddEntriesFrom(input, _repeated_aiaOcspServers_codec);
            break;
          }
          case 42: {
            additionalExtensions_.AddEntriesFrom(input, _repeated_additionalExtensions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (keyUsage_ == null) {
              KeyUsage = new global::Google.Cloud.Security.PrivateCA.V1.KeyUsage();
            }
            input.ReadMessage(KeyUsage);
            break;
          }
          case 18: {
            if (caOptions_ == null) {
              CaOptions = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters.Types.CaOptions();
            }
            input.ReadMessage(CaOptions);
            break;
          }
          case 26: {
            policyIds_.AddEntriesFrom(ref input, _repeated_policyIds_codec);
            break;
          }
          case 34: {
            aiaOcspServers_.AddEntriesFrom(ref input, _repeated_aiaOcspServers_codec);
            break;
          }
          case 42: {
            additionalExtensions_.AddEntriesFrom(ref input, _repeated_additionalExtensions_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the X509Parameters message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Describes values that are relevant in a CA certificate.
      /// </summary>
      public sealed partial class CaOptions : pb::IMessage<CaOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CaOptions> _parser = new pb::MessageParser<CaOptions>(() => new CaOptions());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CaOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.X509Parameters.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CaOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CaOptions(CaOptions other) : this() {
          _hasBits0 = other._hasBits0;
          isCa_ = other.isCa_;
          maxIssuerPathLength_ = other.maxIssuerPathLength_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CaOptions Clone() {
          return new CaOptions(this);
        }

        /// <summary>Field number for the "is_ca" field.</summary>
        public const int IsCaFieldNumber = 1;
        private bool isCa_;
        /// <summary>
        /// Optional. Refers to the "CA" X.509 extension, which is a boolean value. When this
        /// value is missing, the extension will be omitted from the CA certificate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsCa {
          get { if ((_hasBits0 & 1) != 0) { return isCa_; } else { return false; } }
          set {
            _hasBits0 |= 1;
            isCa_ = value;
          }
        }
        /// <summary>Gets whether the "is_ca" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasIsCa {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "is_ca" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearIsCa() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "max_issuer_path_length" field.</summary>
        public const int MaxIssuerPathLengthFieldNumber = 2;
        private int maxIssuerPathLength_;
        /// <summary>
        /// Optional. Refers to the path length restriction X.509 extension. For a CA
        /// certificate, this value describes the depth of subordinate CA
        /// certificates that are allowed.
        /// If this value is less than 0, the request will fail.
        /// If this value is missing, the max path length will be omitted from the
        /// CA certificate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MaxIssuerPathLength {
          get { if ((_hasBits0 & 2) != 0) { return maxIssuerPathLength_; } else { return 0; } }
          set {
            _hasBits0 |= 2;
            maxIssuerPathLength_ = value;
          }
        }
        /// <summary>Gets whether the "max_issuer_path_length" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMaxIssuerPathLength {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "max_issuer_path_length" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMaxIssuerPathLength() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CaOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CaOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (IsCa != other.IsCa) return false;
          if (MaxIssuerPathLength != other.MaxIssuerPathLength) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasIsCa) hash ^= IsCa.GetHashCode();
          if (HasMaxIssuerPathLength) hash ^= MaxIssuerPathLength.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasIsCa) {
            output.WriteRawTag(8);
            output.WriteBool(IsCa);
          }
          if (HasMaxIssuerPathLength) {
            output.WriteRawTag(16);
            output.WriteInt32(MaxIssuerPathLength);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasIsCa) {
            output.WriteRawTag(8);
            output.WriteBool(IsCa);
          }
          if (HasMaxIssuerPathLength) {
            output.WriteRawTag(16);
            output.WriteInt32(MaxIssuerPathLength);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasIsCa) {
            size += 1 + 1;
          }
          if (HasMaxIssuerPathLength) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxIssuerPathLength);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CaOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasIsCa) {
            IsCa = other.IsCa;
          }
          if (other.HasMaxIssuerPathLength) {
            MaxIssuerPathLength = other.MaxIssuerPathLength;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                IsCa = input.ReadBool();
                break;
              }
              case 16: {
                MaxIssuerPathLength = input.ReadInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                IsCa = input.ReadBool();
                break;
              }
              case 16: {
                MaxIssuerPathLength = input.ReadInt32();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Describes a subordinate CA's issuers. This is either a resource name to a
  /// known issuing [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority], or a PEM issuer certificate chain.
  /// </summary>
  public sealed partial class SubordinateConfig : pb::IMessage<SubordinateConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SubordinateConfig> _parser = new pb::MessageParser<SubordinateConfig>(() => new SubordinateConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SubordinateConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubordinateConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubordinateConfig(SubordinateConfig other) : this() {
      switch (other.SubordinateConfigCase) {
        case SubordinateConfigOneofCase.CertificateAuthority:
          CertificateAuthority = other.CertificateAuthority;
          break;
        case SubordinateConfigOneofCase.PemIssuerChain:
          PemIssuerChain = other.PemIssuerChain.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubordinateConfig Clone() {
      return new SubordinateConfig(this);
    }

    /// <summary>Field number for the "certificate_authority" field.</summary>
    public const int CertificateAuthorityFieldNumber = 1;
    /// <summary>
    /// Required. This can refer to a [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] in the same project that
    /// was used to create a subordinate [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]. This field
    /// is used for information and usability purposes only. The resource name
    /// is in the format
    /// `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CertificateAuthority {
      get { return subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority ? (string) subordinateConfig_ : ""; }
      set {
        subordinateConfig_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        subordinateConfigCase_ = SubordinateConfigOneofCase.CertificateAuthority;
      }
    }

    /// <summary>Field number for the "pem_issuer_chain" field.</summary>
    public const int PemIssuerChainFieldNumber = 2;
    /// <summary>
    /// Required. Contains the PEM certificate chain for the issuers of this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority], but not pem certificate for this CA itself.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Types.SubordinateConfigChain PemIssuerChain {
      get { return subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain ? (global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Types.SubordinateConfigChain) subordinateConfig_ : null; }
      set {
        subordinateConfig_ = value;
        subordinateConfigCase_ = value == null ? SubordinateConfigOneofCase.None : SubordinateConfigOneofCase.PemIssuerChain;
      }
    }

    private object subordinateConfig_;
    /// <summary>Enum of possible cases for the "subordinate_config" oneof.</summary>
    public enum SubordinateConfigOneofCase {
      None = 0,
      CertificateAuthority = 1,
      PemIssuerChain = 2,
    }
    private SubordinateConfigOneofCase subordinateConfigCase_ = SubordinateConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubordinateConfigOneofCase SubordinateConfigCase {
      get { return subordinateConfigCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubordinateConfig() {
      subordinateConfigCase_ = SubordinateConfigOneofCase.None;
      subordinateConfig_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SubordinateConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SubordinateConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CertificateAuthority != other.CertificateAuthority) return false;
      if (!object.Equals(PemIssuerChain, other.PemIssuerChain)) return false;
      if (SubordinateConfigCase != other.SubordinateConfigCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority) hash ^= CertificateAuthority.GetHashCode();
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) hash ^= PemIssuerChain.GetHashCode();
      hash ^= (int) subordinateConfigCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority) {
        output.WriteRawTag(10);
        output.WriteString(CertificateAuthority);
      }
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
        output.WriteRawTag(18);
        output.WriteMessage(PemIssuerChain);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority) {
        output.WriteRawTag(10);
        output.WriteString(CertificateAuthority);
      }
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
        output.WriteRawTag(18);
        output.WriteMessage(PemIssuerChain);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.CertificateAuthority) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CertificateAuthority);
      }
      if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PemIssuerChain);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SubordinateConfig other) {
      if (other == null) {
        return;
      }
      switch (other.SubordinateConfigCase) {
        case SubordinateConfigOneofCase.CertificateAuthority:
          CertificateAuthority = other.CertificateAuthority;
          break;
        case SubordinateConfigOneofCase.PemIssuerChain:
          if (PemIssuerChain == null) {
            PemIssuerChain = new global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Types.SubordinateConfigChain();
          }
          PemIssuerChain.MergeFrom(other.PemIssuerChain);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CertificateAuthority = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Types.SubordinateConfigChain subBuilder = new global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Types.SubordinateConfigChain();
            if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
              subBuilder.MergeFrom(PemIssuerChain);
            }
            input.ReadMessage(subBuilder);
            PemIssuerChain = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            CertificateAuthority = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Types.SubordinateConfigChain subBuilder = new global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Types.SubordinateConfigChain();
            if (subordinateConfigCase_ == SubordinateConfigOneofCase.PemIssuerChain) {
              subBuilder.MergeFrom(PemIssuerChain);
            }
            input.ReadMessage(subBuilder);
            PemIssuerChain = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SubordinateConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// This message describes a subordinate CA's issuer certificate chain. This
      /// wrapper exists for compatibility reasons.
      /// </summary>
      public sealed partial class SubordinateConfigChain : pb::IMessage<SubordinateConfigChain>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SubordinateConfigChain> _parser = new pb::MessageParser<SubordinateConfigChain>(() => new SubordinateConfigChain());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SubordinateConfigChain> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.SubordinateConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubordinateConfigChain() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubordinateConfigChain(SubordinateConfigChain other) : this() {
          pemCertificates_ = other.pemCertificates_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubordinateConfigChain Clone() {
          return new SubordinateConfigChain(this);
        }

        /// <summary>Field number for the "pem_certificates" field.</summary>
        public const int PemCertificatesFieldNumber = 1;
        private static readonly pb::FieldCodec<string> _repeated_pemCertificates_codec
            = pb::FieldCodec.ForString(10);
        private readonly pbc::RepeatedField<string> pemCertificates_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Required. Expected to be in leaf-to-root order according to RFC 5246.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> PemCertificates {
          get { return pemCertificates_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SubordinateConfigChain);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SubordinateConfigChain other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!pemCertificates_.Equals(other.pemCertificates_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= pemCertificates_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          pemCertificates_.WriteTo(output, _repeated_pemCertificates_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          pemCertificates_.WriteTo(ref output, _repeated_pemCertificates_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += pemCertificates_.CalculateSize(_repeated_pemCertificates_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SubordinateConfigChain other) {
          if (other == null) {
            return;
          }
          pemCertificates_.Add(other.pemCertificates_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                pemCertificates_.AddEntriesFrom(input, _repeated_pemCertificates_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                pemCertificates_.AddEntriesFrom(ref input, _repeated_pemCertificates_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [PublicKey][google.cloud.security.privateca.v1.PublicKey] describes a public key.
  /// </summary>
  public sealed partial class PublicKey : pb::IMessage<PublicKey>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PublicKey> _parser = new pb::MessageParser<PublicKey>(() => new PublicKey());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PublicKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PublicKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PublicKey(PublicKey other) : this() {
      key_ = other.key_;
      format_ = other.format_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PublicKey Clone() {
      return new PublicKey(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private pb::ByteString key_ = pb::ByteString.Empty;
    /// <summary>
    /// Required. A public key. The padding and encoding
    /// must match with the `KeyFormat` value specified for the `format` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Key {
      get { return key_; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "format" field.</summary>
    public const int FormatFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat format_ = global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat.Unspecified;
    /// <summary>
    /// Required. The format of the public key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat Format {
      get { return format_; }
      set {
        format_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PublicKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PublicKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Format != other.Format) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Key.Length != 0) hash ^= Key.GetHashCode();
      if (Format != global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat.Unspecified) hash ^= Format.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Key.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Key);
      }
      if (Format != global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Format);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Key.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Key);
      }
      if (Format != global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Format);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Key.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Key);
      }
      if (Format != global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Format);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PublicKey other) {
      if (other == null) {
        return;
      }
      if (other.Key.Length != 0) {
        Key = other.Key;
      }
      if (other.Format != global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat.Unspecified) {
        Format = other.Format;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadBytes();
            break;
          }
          case 16: {
            Format = (global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadBytes();
            break;
          }
          case 16: {
            Format = (global::Google.Cloud.Security.PrivateCA.V1.PublicKey.Types.KeyFormat) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the PublicKey message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Types of public keys formats that are supported. Currently, only `PEM`
      /// format is supported.
      /// </summary>
      public enum KeyFormat {
        /// <summary>
        /// Default unspecified value.
        /// </summary>
        [pbr::OriginalName("KEY_FORMAT_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// The key is PEM-encoded as defined in [RFC
        /// 7468](https://tools.ietf.org/html/rfc7468). It can be any of the
        /// following: a PEM-encoded PKCS#1/RFC 3447 RSAPublicKey
        /// structure, an RFC 5280
        /// [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1)
        /// or a PEM-encoded X.509 certificate signing request (CSR). If a
        /// [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1)
        /// is specified, it can contain a A PEM-encoded PKCS#1/RFC 3447 RSAPublicKey
        /// or a NIST P-256/secp256r1/prime256v1 or P-384 key. If a CSR is specified,
        /// it will used solely for the purpose of extracting the public key. When
        /// generated by the service, it will always be an RFC 5280
        /// [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1)
        /// structure containing an algorithm identifier and a key.
        /// </summary>
        [pbr::OriginalName("PEM")] Pem = 1,
      }

    }
    #endregion

  }

  /// <summary>
  /// A [CertificateConfig][google.cloud.security.privateca.v1.CertificateConfig] describes an X.509 certificate or CSR that is to be
  /// created, as an alternative to using ASN.1.
  /// </summary>
  public sealed partial class CertificateConfig : pb::IMessage<CertificateConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateConfig> _parser = new pb::MessageParser<CertificateConfig>(() => new CertificateConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateConfig(CertificateConfig other) : this() {
      subjectConfig_ = other.subjectConfig_ != null ? other.subjectConfig_.Clone() : null;
      x509Config_ = other.x509Config_ != null ? other.x509Config_.Clone() : null;
      publicKey_ = other.publicKey_ != null ? other.publicKey_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateConfig Clone() {
      return new CertificateConfig(this);
    }

    /// <summary>Field number for the "subject_config" field.</summary>
    public const int SubjectConfigFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig.Types.SubjectConfig subjectConfig_;
    /// <summary>
    /// Required. Specifies some of the values in a certificate that are related to the
    /// subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig.Types.SubjectConfig SubjectConfig {
      get { return subjectConfig_; }
      set {
        subjectConfig_ = value;
      }
    }

    /// <summary>Field number for the "x509_config" field.</summary>
    public const int X509ConfigFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1.X509Parameters x509Config_;
    /// <summary>
    /// Required. Describes how some of the technical X.509 fields in a certificate should be
    /// populated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.X509Parameters X509Config {
      get { return x509Config_; }
      set {
        x509Config_ = value;
      }
    }

    /// <summary>Field number for the "public_key" field.</summary>
    public const int PublicKeyFieldNumber = 3;
    private global::Google.Cloud.Security.PrivateCA.V1.PublicKey publicKey_;
    /// <summary>
    /// Optional. The public key that corresponds to this config. This is, for example, used
    /// when issuing [Certificates][google.cloud.security.privateca.v1.Certificate], but not when creating a
    /// self-signed [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] or [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority] CSR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.PublicKey PublicKey {
      get { return publicKey_; }
      set {
        publicKey_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SubjectConfig, other.SubjectConfig)) return false;
      if (!object.Equals(X509Config, other.X509Config)) return false;
      if (!object.Equals(PublicKey, other.PublicKey)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (subjectConfig_ != null) hash ^= SubjectConfig.GetHashCode();
      if (x509Config_ != null) hash ^= X509Config.GetHashCode();
      if (publicKey_ != null) hash ^= PublicKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (subjectConfig_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SubjectConfig);
      }
      if (x509Config_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(X509Config);
      }
      if (publicKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PublicKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (subjectConfig_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SubjectConfig);
      }
      if (x509Config_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(X509Config);
      }
      if (publicKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PublicKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (subjectConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectConfig);
      }
      if (x509Config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(X509Config);
      }
      if (publicKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PublicKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateConfig other) {
      if (other == null) {
        return;
      }
      if (other.subjectConfig_ != null) {
        if (subjectConfig_ == null) {
          SubjectConfig = new global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig.Types.SubjectConfig();
        }
        SubjectConfig.MergeFrom(other.SubjectConfig);
      }
      if (other.x509Config_ != null) {
        if (x509Config_ == null) {
          X509Config = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
        }
        X509Config.MergeFrom(other.X509Config);
      }
      if (other.publicKey_ != null) {
        if (publicKey_ == null) {
          PublicKey = new global::Google.Cloud.Security.PrivateCA.V1.PublicKey();
        }
        PublicKey.MergeFrom(other.PublicKey);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (subjectConfig_ == null) {
              SubjectConfig = new global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig.Types.SubjectConfig();
            }
            input.ReadMessage(SubjectConfig);
            break;
          }
          case 18: {
            if (x509Config_ == null) {
              X509Config = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
            }
            input.ReadMessage(X509Config);
            break;
          }
          case 26: {
            if (publicKey_ == null) {
              PublicKey = new global::Google.Cloud.Security.PrivateCA.V1.PublicKey();
            }
            input.ReadMessage(PublicKey);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (subjectConfig_ == null) {
              SubjectConfig = new global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig.Types.SubjectConfig();
            }
            input.ReadMessage(SubjectConfig);
            break;
          }
          case 18: {
            if (x509Config_ == null) {
              X509Config = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
            }
            input.ReadMessage(X509Config);
            break;
          }
          case 26: {
            if (publicKey_ == null) {
              PublicKey = new global::Google.Cloud.Security.PrivateCA.V1.PublicKey();
            }
            input.ReadMessage(PublicKey);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// These values are used to create the distinguished name and subject
      /// alternative name fields in an X.509 certificate.
      /// </summary>
      public sealed partial class SubjectConfig : pb::IMessage<SubjectConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SubjectConfig> _parser = new pb::MessageParser<SubjectConfig>(() => new SubjectConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SubjectConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.CertificateConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectConfig(SubjectConfig other) : this() {
          subject_ = other.subject_ != null ? other.subject_.Clone() : null;
          subjectAltName_ = other.subjectAltName_ != null ? other.subjectAltName_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectConfig Clone() {
          return new SubjectConfig(this);
        }

        /// <summary>Field number for the "subject" field.</summary>
        public const int SubjectFieldNumber = 1;
        private global::Google.Cloud.Security.PrivateCA.V1.Subject subject_;
        /// <summary>
        /// Required. Contains distinguished name fields such as the common name, location and
        /// organization.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.Subject Subject {
          get { return subject_; }
          set {
            subject_ = value;
          }
        }

        /// <summary>Field number for the "subject_alt_name" field.</summary>
        public const int SubjectAltNameFieldNumber = 2;
        private global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames subjectAltName_;
        /// <summary>
        /// Optional. The subject alternative name fields.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames SubjectAltName {
          get { return subjectAltName_; }
          set {
            subjectAltName_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SubjectConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SubjectConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Subject, other.Subject)) return false;
          if (!object.Equals(SubjectAltName, other.SubjectAltName)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (subject_ != null) hash ^= Subject.GetHashCode();
          if (subjectAltName_ != null) hash ^= SubjectAltName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (subject_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Subject);
          }
          if (subjectAltName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(SubjectAltName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (subject_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Subject);
          }
          if (subjectAltName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(SubjectAltName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (subject_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Subject);
          }
          if (subjectAltName_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectAltName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SubjectConfig other) {
          if (other == null) {
            return;
          }
          if (other.subject_ != null) {
            if (subject_ == null) {
              Subject = new global::Google.Cloud.Security.PrivateCA.V1.Subject();
            }
            Subject.MergeFrom(other.Subject);
          }
          if (other.subjectAltName_ != null) {
            if (subjectAltName_ == null) {
              SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames();
            }
            SubjectAltName.MergeFrom(other.SubjectAltName);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (subject_ == null) {
                  Subject = new global::Google.Cloud.Security.PrivateCA.V1.Subject();
                }
                input.ReadMessage(Subject);
                break;
              }
              case 18: {
                if (subjectAltName_ == null) {
                  SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames();
                }
                input.ReadMessage(SubjectAltName);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (subject_ == null) {
                  Subject = new global::Google.Cloud.Security.PrivateCA.V1.Subject();
                }
                input.ReadMessage(Subject);
                break;
              }
              case 18: {
                if (subjectAltName_ == null) {
                  SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames();
                }
                input.ReadMessage(SubjectAltName);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A [CertificateDescription][google.cloud.security.privateca.v1.CertificateDescription] describes an X.509 certificate or CSR that has
  /// been issued, as an alternative to using ASN.1 / X.509.
  /// </summary>
  public sealed partial class CertificateDescription : pb::IMessage<CertificateDescription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateDescription> _parser = new pb::MessageParser<CertificateDescription>(() => new CertificateDescription());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateDescription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateDescription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateDescription(CertificateDescription other) : this() {
      subjectDescription_ = other.subjectDescription_ != null ? other.subjectDescription_.Clone() : null;
      x509Description_ = other.x509Description_ != null ? other.x509Description_.Clone() : null;
      publicKey_ = other.publicKey_ != null ? other.publicKey_.Clone() : null;
      subjectKeyId_ = other.subjectKeyId_ != null ? other.subjectKeyId_.Clone() : null;
      authorityKeyId_ = other.authorityKeyId_ != null ? other.authorityKeyId_.Clone() : null;
      crlDistributionPoints_ = other.crlDistributionPoints_.Clone();
      aiaIssuingCertificateUrls_ = other.aiaIssuingCertificateUrls_.Clone();
      certFingerprint_ = other.certFingerprint_ != null ? other.certFingerprint_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateDescription Clone() {
      return new CertificateDescription(this);
    }

    /// <summary>Field number for the "subject_description" field.</summary>
    public const int SubjectDescriptionFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.SubjectDescription subjectDescription_;
    /// <summary>
    /// Describes some of the values in a certificate that are related to the
    /// subject and lifetime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.SubjectDescription SubjectDescription {
      get { return subjectDescription_; }
      set {
        subjectDescription_ = value;
      }
    }

    /// <summary>Field number for the "x509_description" field.</summary>
    public const int X509DescriptionFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1.X509Parameters x509Description_;
    /// <summary>
    /// Describes some of the technical X.509 fields in a certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.X509Parameters X509Description {
      get { return x509Description_; }
      set {
        x509Description_ = value;
      }
    }

    /// <summary>Field number for the "public_key" field.</summary>
    public const int PublicKeyFieldNumber = 3;
    private global::Google.Cloud.Security.PrivateCA.V1.PublicKey publicKey_;
    /// <summary>
    /// The public key that corresponds to an issued certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.PublicKey PublicKey {
      get { return publicKey_; }
      set {
        publicKey_ = value;
      }
    }

    /// <summary>Field number for the "subject_key_id" field.</summary>
    public const int SubjectKeyIdFieldNumber = 4;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId subjectKeyId_;
    /// <summary>
    /// Provides a means of identifiying certificates that contain a particular
    /// public key, per https://tools.ietf.org/html/rfc5280#section-4.2.1.2.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId SubjectKeyId {
      get { return subjectKeyId_; }
      set {
        subjectKeyId_ = value;
      }
    }

    /// <summary>Field number for the "authority_key_id" field.</summary>
    public const int AuthorityKeyIdFieldNumber = 5;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId authorityKeyId_;
    /// <summary>
    /// Identifies the subject_key_id of the parent certificate, per
    /// https://tools.ietf.org/html/rfc5280#section-4.2.1.1
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId AuthorityKeyId {
      get { return authorityKeyId_; }
      set {
        authorityKeyId_ = value;
      }
    }

    /// <summary>Field number for the "crl_distribution_points" field.</summary>
    public const int CrlDistributionPointsFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_crlDistributionPoints_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> crlDistributionPoints_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Describes a list of locations to obtain CRL information, i.e.
    /// the DistributionPoint.fullName described by
    /// https://tools.ietf.org/html/rfc5280#section-4.2.1.13
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CrlDistributionPoints {
      get { return crlDistributionPoints_; }
    }

    /// <summary>Field number for the "aia_issuing_certificate_urls" field.</summary>
    public const int AiaIssuingCertificateUrlsFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_aiaIssuingCertificateUrls_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> aiaIssuingCertificateUrls_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Describes lists of issuer CA certificate URLs that appear in the
    /// "Authority Information Access" extension in the certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> AiaIssuingCertificateUrls {
      get { return aiaIssuingCertificateUrls_; }
    }

    /// <summary>Field number for the "cert_fingerprint" field.</summary>
    public const int CertFingerprintFieldNumber = 8;
    private global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.CertificateFingerprint certFingerprint_;
    /// <summary>
    /// The hash of the x.509 certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.CertificateFingerprint CertFingerprint {
      get { return certFingerprint_; }
      set {
        certFingerprint_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateDescription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateDescription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SubjectDescription, other.SubjectDescription)) return false;
      if (!object.Equals(X509Description, other.X509Description)) return false;
      if (!object.Equals(PublicKey, other.PublicKey)) return false;
      if (!object.Equals(SubjectKeyId, other.SubjectKeyId)) return false;
      if (!object.Equals(AuthorityKeyId, other.AuthorityKeyId)) return false;
      if(!crlDistributionPoints_.Equals(other.crlDistributionPoints_)) return false;
      if(!aiaIssuingCertificateUrls_.Equals(other.aiaIssuingCertificateUrls_)) return false;
      if (!object.Equals(CertFingerprint, other.CertFingerprint)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (subjectDescription_ != null) hash ^= SubjectDescription.GetHashCode();
      if (x509Description_ != null) hash ^= X509Description.GetHashCode();
      if (publicKey_ != null) hash ^= PublicKey.GetHashCode();
      if (subjectKeyId_ != null) hash ^= SubjectKeyId.GetHashCode();
      if (authorityKeyId_ != null) hash ^= AuthorityKeyId.GetHashCode();
      hash ^= crlDistributionPoints_.GetHashCode();
      hash ^= aiaIssuingCertificateUrls_.GetHashCode();
      if (certFingerprint_ != null) hash ^= CertFingerprint.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (subjectDescription_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SubjectDescription);
      }
      if (x509Description_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(X509Description);
      }
      if (publicKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PublicKey);
      }
      if (subjectKeyId_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SubjectKeyId);
      }
      if (authorityKeyId_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AuthorityKeyId);
      }
      crlDistributionPoints_.WriteTo(output, _repeated_crlDistributionPoints_codec);
      aiaIssuingCertificateUrls_.WriteTo(output, _repeated_aiaIssuingCertificateUrls_codec);
      if (certFingerprint_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(CertFingerprint);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (subjectDescription_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SubjectDescription);
      }
      if (x509Description_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(X509Description);
      }
      if (publicKey_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PublicKey);
      }
      if (subjectKeyId_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SubjectKeyId);
      }
      if (authorityKeyId_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AuthorityKeyId);
      }
      crlDistributionPoints_.WriteTo(ref output, _repeated_crlDistributionPoints_codec);
      aiaIssuingCertificateUrls_.WriteTo(ref output, _repeated_aiaIssuingCertificateUrls_codec);
      if (certFingerprint_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(CertFingerprint);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (subjectDescription_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectDescription);
      }
      if (x509Description_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(X509Description);
      }
      if (publicKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PublicKey);
      }
      if (subjectKeyId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectKeyId);
      }
      if (authorityKeyId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthorityKeyId);
      }
      size += crlDistributionPoints_.CalculateSize(_repeated_crlDistributionPoints_codec);
      size += aiaIssuingCertificateUrls_.CalculateSize(_repeated_aiaIssuingCertificateUrls_codec);
      if (certFingerprint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CertFingerprint);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateDescription other) {
      if (other == null) {
        return;
      }
      if (other.subjectDescription_ != null) {
        if (subjectDescription_ == null) {
          SubjectDescription = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.SubjectDescription();
        }
        SubjectDescription.MergeFrom(other.SubjectDescription);
      }
      if (other.x509Description_ != null) {
        if (x509Description_ == null) {
          X509Description = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
        }
        X509Description.MergeFrom(other.X509Description);
      }
      if (other.publicKey_ != null) {
        if (publicKey_ == null) {
          PublicKey = new global::Google.Cloud.Security.PrivateCA.V1.PublicKey();
        }
        PublicKey.MergeFrom(other.PublicKey);
      }
      if (other.subjectKeyId_ != null) {
        if (subjectKeyId_ == null) {
          SubjectKeyId = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId();
        }
        SubjectKeyId.MergeFrom(other.SubjectKeyId);
      }
      if (other.authorityKeyId_ != null) {
        if (authorityKeyId_ == null) {
          AuthorityKeyId = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId();
        }
        AuthorityKeyId.MergeFrom(other.AuthorityKeyId);
      }
      crlDistributionPoints_.Add(other.crlDistributionPoints_);
      aiaIssuingCertificateUrls_.Add(other.aiaIssuingCertificateUrls_);
      if (other.certFingerprint_ != null) {
        if (certFingerprint_ == null) {
          CertFingerprint = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.CertificateFingerprint();
        }
        CertFingerprint.MergeFrom(other.CertFingerprint);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (subjectDescription_ == null) {
              SubjectDescription = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.SubjectDescription();
            }
            input.ReadMessage(SubjectDescription);
            break;
          }
          case 18: {
            if (x509Description_ == null) {
              X509Description = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
            }
            input.ReadMessage(X509Description);
            break;
          }
          case 26: {
            if (publicKey_ == null) {
              PublicKey = new global::Google.Cloud.Security.PrivateCA.V1.PublicKey();
            }
            input.ReadMessage(PublicKey);
            break;
          }
          case 34: {
            if (subjectKeyId_ == null) {
              SubjectKeyId = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId();
            }
            input.ReadMessage(SubjectKeyId);
            break;
          }
          case 42: {
            if (authorityKeyId_ == null) {
              AuthorityKeyId = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId();
            }
            input.ReadMessage(AuthorityKeyId);
            break;
          }
          case 50: {
            crlDistributionPoints_.AddEntriesFrom(input, _repeated_crlDistributionPoints_codec);
            break;
          }
          case 58: {
            aiaIssuingCertificateUrls_.AddEntriesFrom(input, _repeated_aiaIssuingCertificateUrls_codec);
            break;
          }
          case 66: {
            if (certFingerprint_ == null) {
              CertFingerprint = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.CertificateFingerprint();
            }
            input.ReadMessage(CertFingerprint);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (subjectDescription_ == null) {
              SubjectDescription = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.SubjectDescription();
            }
            input.ReadMessage(SubjectDescription);
            break;
          }
          case 18: {
            if (x509Description_ == null) {
              X509Description = new global::Google.Cloud.Security.PrivateCA.V1.X509Parameters();
            }
            input.ReadMessage(X509Description);
            break;
          }
          case 26: {
            if (publicKey_ == null) {
              PublicKey = new global::Google.Cloud.Security.PrivateCA.V1.PublicKey();
            }
            input.ReadMessage(PublicKey);
            break;
          }
          case 34: {
            if (subjectKeyId_ == null) {
              SubjectKeyId = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId();
            }
            input.ReadMessage(SubjectKeyId);
            break;
          }
          case 42: {
            if (authorityKeyId_ == null) {
              AuthorityKeyId = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.KeyId();
            }
            input.ReadMessage(AuthorityKeyId);
            break;
          }
          case 50: {
            crlDistributionPoints_.AddEntriesFrom(ref input, _repeated_crlDistributionPoints_codec);
            break;
          }
          case 58: {
            aiaIssuingCertificateUrls_.AddEntriesFrom(ref input, _repeated_aiaIssuingCertificateUrls_codec);
            break;
          }
          case 66: {
            if (certFingerprint_ == null) {
              CertFingerprint = new global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Types.CertificateFingerprint();
            }
            input.ReadMessage(CertFingerprint);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateDescription message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// These values describe fields in an issued X.509 certificate such as the
      /// distinguished name, subject alternative names, serial number, and lifetime.
      /// </summary>
      public sealed partial class SubjectDescription : pb::IMessage<SubjectDescription>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SubjectDescription> _parser = new pb::MessageParser<SubjectDescription>(() => new SubjectDescription());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SubjectDescription> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectDescription() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectDescription(SubjectDescription other) : this() {
          subject_ = other.subject_ != null ? other.subject_.Clone() : null;
          subjectAltName_ = other.subjectAltName_ != null ? other.subjectAltName_.Clone() : null;
          hexSerialNumber_ = other.hexSerialNumber_;
          lifetime_ = other.lifetime_ != null ? other.lifetime_.Clone() : null;
          notBeforeTime_ = other.notBeforeTime_ != null ? other.notBeforeTime_.Clone() : null;
          notAfterTime_ = other.notAfterTime_ != null ? other.notAfterTime_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SubjectDescription Clone() {
          return new SubjectDescription(this);
        }

        /// <summary>Field number for the "subject" field.</summary>
        public const int SubjectFieldNumber = 1;
        private global::Google.Cloud.Security.PrivateCA.V1.Subject subject_;
        /// <summary>
        /// Contains distinguished name fields such as the common name, location and
        /// / organization.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.Subject Subject {
          get { return subject_; }
          set {
            subject_ = value;
          }
        }

        /// <summary>Field number for the "subject_alt_name" field.</summary>
        public const int SubjectAltNameFieldNumber = 2;
        private global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames subjectAltName_;
        /// <summary>
        /// The subject alternative name fields.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames SubjectAltName {
          get { return subjectAltName_; }
          set {
            subjectAltName_ = value;
          }
        }

        /// <summary>Field number for the "hex_serial_number" field.</summary>
        public const int HexSerialNumberFieldNumber = 3;
        private string hexSerialNumber_ = "";
        /// <summary>
        /// The serial number encoded in lowercase hexadecimal.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string HexSerialNumber {
          get { return hexSerialNumber_; }
          set {
            hexSerialNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "lifetime" field.</summary>
        public const int LifetimeFieldNumber = 4;
        private global::Google.Protobuf.WellKnownTypes.Duration lifetime_;
        /// <summary>
        /// For convenience, the actual lifetime of an issued certificate.
        /// Corresponds to 'not_after_time' - 'not_before_time'.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration Lifetime {
          get { return lifetime_; }
          set {
            lifetime_ = value;
          }
        }

        /// <summary>Field number for the "not_before_time" field.</summary>
        public const int NotBeforeTimeFieldNumber = 5;
        private global::Google.Protobuf.WellKnownTypes.Timestamp notBeforeTime_;
        /// <summary>
        /// The time at which the certificate becomes valid.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp NotBeforeTime {
          get { return notBeforeTime_; }
          set {
            notBeforeTime_ = value;
          }
        }

        /// <summary>Field number for the "not_after_time" field.</summary>
        public const int NotAfterTimeFieldNumber = 6;
        private global::Google.Protobuf.WellKnownTypes.Timestamp notAfterTime_;
        /// <summary>
        /// The time at which the certificate expires.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Timestamp NotAfterTime {
          get { return notAfterTime_; }
          set {
            notAfterTime_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SubjectDescription);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SubjectDescription other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Subject, other.Subject)) return false;
          if (!object.Equals(SubjectAltName, other.SubjectAltName)) return false;
          if (HexSerialNumber != other.HexSerialNumber) return false;
          if (!object.Equals(Lifetime, other.Lifetime)) return false;
          if (!object.Equals(NotBeforeTime, other.NotBeforeTime)) return false;
          if (!object.Equals(NotAfterTime, other.NotAfterTime)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (subject_ != null) hash ^= Subject.GetHashCode();
          if (subjectAltName_ != null) hash ^= SubjectAltName.GetHashCode();
          if (HexSerialNumber.Length != 0) hash ^= HexSerialNumber.GetHashCode();
          if (lifetime_ != null) hash ^= Lifetime.GetHashCode();
          if (notBeforeTime_ != null) hash ^= NotBeforeTime.GetHashCode();
          if (notAfterTime_ != null) hash ^= NotAfterTime.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (subject_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Subject);
          }
          if (subjectAltName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(SubjectAltName);
          }
          if (HexSerialNumber.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(HexSerialNumber);
          }
          if (lifetime_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(Lifetime);
          }
          if (notBeforeTime_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(NotBeforeTime);
          }
          if (notAfterTime_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(NotAfterTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (subject_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Subject);
          }
          if (subjectAltName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(SubjectAltName);
          }
          if (HexSerialNumber.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(HexSerialNumber);
          }
          if (lifetime_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(Lifetime);
          }
          if (notBeforeTime_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(NotBeforeTime);
          }
          if (notAfterTime_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(NotAfterTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (subject_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Subject);
          }
          if (subjectAltName_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubjectAltName);
          }
          if (HexSerialNumber.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(HexSerialNumber);
          }
          if (lifetime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lifetime);
          }
          if (notBeforeTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotBeforeTime);
          }
          if (notAfterTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotAfterTime);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SubjectDescription other) {
          if (other == null) {
            return;
          }
          if (other.subject_ != null) {
            if (subject_ == null) {
              Subject = new global::Google.Cloud.Security.PrivateCA.V1.Subject();
            }
            Subject.MergeFrom(other.Subject);
          }
          if (other.subjectAltName_ != null) {
            if (subjectAltName_ == null) {
              SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames();
            }
            SubjectAltName.MergeFrom(other.SubjectAltName);
          }
          if (other.HexSerialNumber.Length != 0) {
            HexSerialNumber = other.HexSerialNumber;
          }
          if (other.lifetime_ != null) {
            if (lifetime_ == null) {
              Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            Lifetime.MergeFrom(other.Lifetime);
          }
          if (other.notBeforeTime_ != null) {
            if (notBeforeTime_ == null) {
              NotBeforeTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            NotBeforeTime.MergeFrom(other.NotBeforeTime);
          }
          if (other.notAfterTime_ != null) {
            if (notAfterTime_ == null) {
              NotAfterTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            NotAfterTime.MergeFrom(other.NotAfterTime);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (subject_ == null) {
                  Subject = new global::Google.Cloud.Security.PrivateCA.V1.Subject();
                }
                input.ReadMessage(Subject);
                break;
              }
              case 18: {
                if (subjectAltName_ == null) {
                  SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames();
                }
                input.ReadMessage(SubjectAltName);
                break;
              }
              case 26: {
                HexSerialNumber = input.ReadString();
                break;
              }
              case 34: {
                if (lifetime_ == null) {
                  Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Lifetime);
                break;
              }
              case 42: {
                if (notBeforeTime_ == null) {
                  NotBeforeTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(NotBeforeTime);
                break;
              }
              case 50: {
                if (notAfterTime_ == null) {
                  NotAfterTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(NotAfterTime);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (subject_ == null) {
                  Subject = new global::Google.Cloud.Security.PrivateCA.V1.Subject();
                }
                input.ReadMessage(Subject);
                break;
              }
              case 18: {
                if (subjectAltName_ == null) {
                  SubjectAltName = new global::Google.Cloud.Security.PrivateCA.V1.SubjectAltNames();
                }
                input.ReadMessage(SubjectAltName);
                break;
              }
              case 26: {
                HexSerialNumber = input.ReadString();
                break;
              }
              case 34: {
                if (lifetime_ == null) {
                  Lifetime = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Lifetime);
                break;
              }
              case 42: {
                if (notBeforeTime_ == null) {
                  NotBeforeTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(NotBeforeTime);
                break;
              }
              case 50: {
                if (notAfterTime_ == null) {
                  NotAfterTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(NotAfterTime);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// A KeyId identifies a specific public key, usually by hashing the public
      /// key.
      /// </summary>
      public sealed partial class KeyId : pb::IMessage<KeyId>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<KeyId> _parser = new pb::MessageParser<KeyId>(() => new KeyId());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<KeyId> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyId() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyId(KeyId other) : this() {
          keyId_ = other.keyId_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyId Clone() {
          return new KeyId(this);
        }

        /// <summary>Field number for the "key_id" field.</summary>
        public const int KeyId_FieldNumber = 1;
        private string keyId_ = "";
        /// <summary>
        /// Optional. The value of this KeyId encoded in lowercase hexadecimal. This is most
        /// likely the 160 bit SHA-1 hash of the public key.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string KeyId_ {
          get { return keyId_; }
          set {
            keyId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as KeyId);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(KeyId other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (KeyId_ != other.KeyId_) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (KeyId_.Length != 0) hash ^= KeyId_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (KeyId_.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(KeyId_);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (KeyId_.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(KeyId_);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (KeyId_.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(KeyId_);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(KeyId other) {
          if (other == null) {
            return;
          }
          if (other.KeyId_.Length != 0) {
            KeyId_ = other.KeyId_;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                KeyId_ = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                KeyId_ = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// A group of fingerprints for the x509 certificate.
      /// </summary>
      public sealed partial class CertificateFingerprint : pb::IMessage<CertificateFingerprint>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CertificateFingerprint> _parser = new pb::MessageParser<CertificateFingerprint>(() => new CertificateFingerprint());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CertificateFingerprint> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.CertificateDescription.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CertificateFingerprint() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CertificateFingerprint(CertificateFingerprint other) : this() {
          sha256Hash_ = other.sha256Hash_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CertificateFingerprint Clone() {
          return new CertificateFingerprint(this);
        }

        /// <summary>Field number for the "sha256_hash" field.</summary>
        public const int Sha256HashFieldNumber = 1;
        private string sha256Hash_ = "";
        /// <summary>
        /// The SHA 256 hash, encoded in hexadecimal, of the DER x509 certificate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Sha256Hash {
          get { return sha256Hash_; }
          set {
            sha256Hash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CertificateFingerprint);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CertificateFingerprint other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Sha256Hash != other.Sha256Hash) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Sha256Hash.Length != 0) hash ^= Sha256Hash.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Sha256Hash.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Sha256Hash);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Sha256Hash.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Sha256Hash);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Sha256Hash.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Sha256Hash);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CertificateFingerprint other) {
          if (other == null) {
            return;
          }
          if (other.Sha256Hash.Length != 0) {
            Sha256Hash = other.Sha256Hash;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Sha256Hash = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Sha256Hash = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// An [ObjectId][google.cloud.security.privateca.v1.ObjectId] specifies an object identifier (OID). These provide context
  /// and describe types in ASN.1 messages.
  /// </summary>
  public sealed partial class ObjectId : pb::IMessage<ObjectId>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ObjectId> _parser = new pb::MessageParser<ObjectId>(() => new ObjectId());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ObjectId> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectId() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectId(ObjectId other) : this() {
      objectIdPath_ = other.objectIdPath_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ObjectId Clone() {
      return new ObjectId(this);
    }

    /// <summary>Field number for the "object_id_path" field.</summary>
    public const int ObjectIdPathFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_objectIdPath_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> objectIdPath_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Required. The parts of an OID path. The most significant parts of the path come
    /// first.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> ObjectIdPath {
      get { return objectIdPath_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ObjectId);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ObjectId other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!objectIdPath_.Equals(other.objectIdPath_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= objectIdPath_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      objectIdPath_.WriteTo(output, _repeated_objectIdPath_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      objectIdPath_.WriteTo(ref output, _repeated_objectIdPath_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += objectIdPath_.CalculateSize(_repeated_objectIdPath_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ObjectId other) {
      if (other == null) {
        return;
      }
      objectIdPath_.Add(other.objectIdPath_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            objectIdPath_.AddEntriesFrom(input, _repeated_objectIdPath_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            objectIdPath_.AddEntriesFrom(ref input, _repeated_objectIdPath_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// An [X509Extension][google.cloud.security.privateca.v1.X509Extension] specifies an X.509 extension, which may be used in
  /// different parts of X.509 objects like certificates, CSRs, and CRLs.
  /// </summary>
  public sealed partial class X509Extension : pb::IMessage<X509Extension>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<X509Extension> _parser = new pb::MessageParser<X509Extension>(() => new X509Extension());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<X509Extension> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public X509Extension() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public X509Extension(X509Extension other) : this() {
      objectId_ = other.objectId_ != null ? other.objectId_.Clone() : null;
      critical_ = other.critical_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public X509Extension Clone() {
      return new X509Extension(this);
    }

    /// <summary>Field number for the "object_id" field.</summary>
    public const int ObjectIdFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1.ObjectId objectId_;
    /// <summary>
    /// Required. The OID for this X.509 extension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.ObjectId ObjectId {
      get { return objectId_; }
      set {
        objectId_ = value;
      }
    }

    /// <summary>Field number for the "critical" field.</summary>
    public const int CriticalFieldNumber = 2;
    private bool critical_;
    /// <summary>
    /// Required. Indicates whether or not this extension is critical (i.e., if the client
    /// does not know how to handle this extension, the client should consider this
    /// to be an error).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Critical {
      get { return critical_; }
      set {
        critical_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 3;
    private pb::ByteString value_ = pb::ByteString.Empty;
    /// <summary>
    /// Required. The value of this X.509 extension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as X509Extension);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(X509Extension other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ObjectId, other.ObjectId)) return false;
      if (Critical != other.Critical) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (objectId_ != null) hash ^= ObjectId.GetHashCode();
      if (Critical != false) hash ^= Critical.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (objectId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ObjectId);
      }
      if (Critical != false) {
        output.WriteRawTag(16);
        output.WriteBool(Critical);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (objectId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ObjectId);
      }
      if (Critical != false) {
        output.WriteRawTag(16);
        output.WriteBool(Critical);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (objectId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ObjectId);
      }
      if (Critical != false) {
        size += 1 + 1;
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(X509Extension other) {
      if (other == null) {
        return;
      }
      if (other.objectId_ != null) {
        if (objectId_ == null) {
          ObjectId = new global::Google.Cloud.Security.PrivateCA.V1.ObjectId();
        }
        ObjectId.MergeFrom(other.ObjectId);
      }
      if (other.Critical != false) {
        Critical = other.Critical;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (objectId_ == null) {
              ObjectId = new global::Google.Cloud.Security.PrivateCA.V1.ObjectId();
            }
            input.ReadMessage(ObjectId);
            break;
          }
          case 16: {
            Critical = input.ReadBool();
            break;
          }
          case 26: {
            Value = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (objectId_ == null) {
              ObjectId = new global::Google.Cloud.Security.PrivateCA.V1.ObjectId();
            }
            input.ReadMessage(ObjectId);
            break;
          }
          case 16: {
            Critical = input.ReadBool();
            break;
          }
          case 26: {
            Value = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A [KeyUsage][google.cloud.security.privateca.v1.KeyUsage] describes key usage values that may appear in an X.509
  /// certificate.
  /// </summary>
  public sealed partial class KeyUsage : pb::IMessage<KeyUsage>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyUsage> _parser = new pb::MessageParser<KeyUsage>(() => new KeyUsage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<KeyUsage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeyUsage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeyUsage(KeyUsage other) : this() {
      baseKeyUsage_ = other.baseKeyUsage_ != null ? other.baseKeyUsage_.Clone() : null;
      extendedKeyUsage_ = other.extendedKeyUsage_ != null ? other.extendedKeyUsage_.Clone() : null;
      unknownExtendedKeyUsages_ = other.unknownExtendedKeyUsages_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public KeyUsage Clone() {
      return new KeyUsage(this);
    }

    /// <summary>Field number for the "base_key_usage" field.</summary>
    public const int BaseKeyUsageFieldNumber = 1;
    private global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.KeyUsageOptions baseKeyUsage_;
    /// <summary>
    /// Describes high-level ways in which a key may be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.KeyUsageOptions BaseKeyUsage {
      get { return baseKeyUsage_; }
      set {
        baseKeyUsage_ = value;
      }
    }

    /// <summary>Field number for the "extended_key_usage" field.</summary>
    public const int ExtendedKeyUsageFieldNumber = 2;
    private global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.ExtendedKeyUsageOptions extendedKeyUsage_;
    /// <summary>
    /// Detailed scenarios in which a key may be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.ExtendedKeyUsageOptions ExtendedKeyUsage {
      get { return extendedKeyUsage_; }
      set {
        extendedKeyUsage_ = value;
      }
    }

    /// <summary>Field number for the "unknown_extended_key_usages" field.</summary>
    public const int UnknownExtendedKeyUsagesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1.ObjectId> _repeated_unknownExtendedKeyUsages_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Cloud.Security.PrivateCA.V1.ObjectId.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.ObjectId> unknownExtendedKeyUsages_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.ObjectId>();
    /// <summary>
    /// Used to describe extended key usages that are not listed in the
    /// [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1.KeyUsage.ExtendedKeyUsageOptions] message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.ObjectId> UnknownExtendedKeyUsages {
      get { return unknownExtendedKeyUsages_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as KeyUsage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(KeyUsage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(BaseKeyUsage, other.BaseKeyUsage)) return false;
      if (!object.Equals(ExtendedKeyUsage, other.ExtendedKeyUsage)) return false;
      if(!unknownExtendedKeyUsages_.Equals(other.unknownExtendedKeyUsages_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (baseKeyUsage_ != null) hash ^= BaseKeyUsage.GetHashCode();
      if (extendedKeyUsage_ != null) hash ^= ExtendedKeyUsage.GetHashCode();
      hash ^= unknownExtendedKeyUsages_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (baseKeyUsage_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(BaseKeyUsage);
      }
      if (extendedKeyUsage_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExtendedKeyUsage);
      }
      unknownExtendedKeyUsages_.WriteTo(output, _repeated_unknownExtendedKeyUsages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (baseKeyUsage_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(BaseKeyUsage);
      }
      if (extendedKeyUsage_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ExtendedKeyUsage);
      }
      unknownExtendedKeyUsages_.WriteTo(ref output, _repeated_unknownExtendedKeyUsages_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (baseKeyUsage_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaseKeyUsage);
      }
      if (extendedKeyUsage_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExtendedKeyUsage);
      }
      size += unknownExtendedKeyUsages_.CalculateSize(_repeated_unknownExtendedKeyUsages_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(KeyUsage other) {
      if (other == null) {
        return;
      }
      if (other.baseKeyUsage_ != null) {
        if (baseKeyUsage_ == null) {
          BaseKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.KeyUsageOptions();
        }
        BaseKeyUsage.MergeFrom(other.BaseKeyUsage);
      }
      if (other.extendedKeyUsage_ != null) {
        if (extendedKeyUsage_ == null) {
          ExtendedKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.ExtendedKeyUsageOptions();
        }
        ExtendedKeyUsage.MergeFrom(other.ExtendedKeyUsage);
      }
      unknownExtendedKeyUsages_.Add(other.unknownExtendedKeyUsages_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (baseKeyUsage_ == null) {
              BaseKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.KeyUsageOptions();
            }
            input.ReadMessage(BaseKeyUsage);
            break;
          }
          case 18: {
            if (extendedKeyUsage_ == null) {
              ExtendedKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.ExtendedKeyUsageOptions();
            }
            input.ReadMessage(ExtendedKeyUsage);
            break;
          }
          case 26: {
            unknownExtendedKeyUsages_.AddEntriesFrom(input, _repeated_unknownExtendedKeyUsages_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (baseKeyUsage_ == null) {
              BaseKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.KeyUsageOptions();
            }
            input.ReadMessage(BaseKeyUsage);
            break;
          }
          case 18: {
            if (extendedKeyUsage_ == null) {
              ExtendedKeyUsage = new global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Types.ExtendedKeyUsageOptions();
            }
            input.ReadMessage(ExtendedKeyUsage);
            break;
          }
          case 26: {
            unknownExtendedKeyUsages_.AddEntriesFrom(ref input, _repeated_unknownExtendedKeyUsages_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the KeyUsage message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// [KeyUsage.KeyUsageOptions][google.cloud.security.privateca.v1.KeyUsage.KeyUsageOptions] corresponds to the key usage values
      /// described in https://tools.ietf.org/html/rfc5280#section-4.2.1.3.
      /// </summary>
      public sealed partial class KeyUsageOptions : pb::IMessage<KeyUsageOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<KeyUsageOptions> _parser = new pb::MessageParser<KeyUsageOptions>(() => new KeyUsageOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<KeyUsageOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyUsageOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyUsageOptions(KeyUsageOptions other) : this() {
          digitalSignature_ = other.digitalSignature_;
          contentCommitment_ = other.contentCommitment_;
          keyEncipherment_ = other.keyEncipherment_;
          dataEncipherment_ = other.dataEncipherment_;
          keyAgreement_ = other.keyAgreement_;
          certSign_ = other.certSign_;
          crlSign_ = other.crlSign_;
          encipherOnly_ = other.encipherOnly_;
          decipherOnly_ = other.decipherOnly_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public KeyUsageOptions Clone() {
          return new KeyUsageOptions(this);
        }

        /// <summary>Field number for the "digital_signature" field.</summary>
        public const int DigitalSignatureFieldNumber = 1;
        private bool digitalSignature_;
        /// <summary>
        /// The key may be used for digital signatures.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool DigitalSignature {
          get { return digitalSignature_; }
          set {
            digitalSignature_ = value;
          }
        }

        /// <summary>Field number for the "content_commitment" field.</summary>
        public const int ContentCommitmentFieldNumber = 2;
        private bool contentCommitment_;
        /// <summary>
        /// The key may be used for cryptographic commitments. Note that this may
        /// also be referred to as "non-repudiation".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ContentCommitment {
          get { return contentCommitment_; }
          set {
            contentCommitment_ = value;
          }
        }

        /// <summary>Field number for the "key_encipherment" field.</summary>
        public const int KeyEnciphermentFieldNumber = 3;
        private bool keyEncipherment_;
        /// <summary>
        /// The key may be used to encipher other keys.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool KeyEncipherment {
          get { return keyEncipherment_; }
          set {
            keyEncipherment_ = value;
          }
        }

        /// <summary>Field number for the "data_encipherment" field.</summary>
        public const int DataEnciphermentFieldNumber = 4;
        private bool dataEncipherment_;
        /// <summary>
        /// The key may be used to encipher data.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool DataEncipherment {
          get { return dataEncipherment_; }
          set {
            dataEncipherment_ = value;
          }
        }

        /// <summary>Field number for the "key_agreement" field.</summary>
        public const int KeyAgreementFieldNumber = 5;
        private bool keyAgreement_;
        /// <summary>
        /// The key may be used in a key agreement protocol.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool KeyAgreement {
          get { return keyAgreement_; }
          set {
            keyAgreement_ = value;
          }
        }

        /// <summary>Field number for the "cert_sign" field.</summary>
        public const int CertSignFieldNumber = 6;
        private bool certSign_;
        /// <summary>
        /// The key may be used to sign certificates.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CertSign {
          get { return certSign_; }
          set {
            certSign_ = value;
          }
        }

        /// <summary>Field number for the "crl_sign" field.</summary>
        public const int CrlSignFieldNumber = 7;
        private bool crlSign_;
        /// <summary>
        /// The key may be used sign certificate revocation lists.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CrlSign {
          get { return crlSign_; }
          set {
            crlSign_ = value;
          }
        }

        /// <summary>Field number for the "encipher_only" field.</summary>
        public const int EncipherOnlyFieldNumber = 8;
        private bool encipherOnly_;
        /// <summary>
        /// The key may be used to encipher only.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool EncipherOnly {
          get { return encipherOnly_; }
          set {
            encipherOnly_ = value;
          }
        }

        /// <summary>Field number for the "decipher_only" field.</summary>
        public const int DecipherOnlyFieldNumber = 9;
        private bool decipherOnly_;
        /// <summary>
        /// The key may be used to decipher only.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool DecipherOnly {
          get { return decipherOnly_; }
          set {
            decipherOnly_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as KeyUsageOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(KeyUsageOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DigitalSignature != other.DigitalSignature) return false;
          if (ContentCommitment != other.ContentCommitment) return false;
          if (KeyEncipherment != other.KeyEncipherment) return false;
          if (DataEncipherment != other.DataEncipherment) return false;
          if (KeyAgreement != other.KeyAgreement) return false;
          if (CertSign != other.CertSign) return false;
          if (CrlSign != other.CrlSign) return false;
          if (EncipherOnly != other.EncipherOnly) return false;
          if (DecipherOnly != other.DecipherOnly) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (DigitalSignature != false) hash ^= DigitalSignature.GetHashCode();
          if (ContentCommitment != false) hash ^= ContentCommitment.GetHashCode();
          if (KeyEncipherment != false) hash ^= KeyEncipherment.GetHashCode();
          if (DataEncipherment != false) hash ^= DataEncipherment.GetHashCode();
          if (KeyAgreement != false) hash ^= KeyAgreement.GetHashCode();
          if (CertSign != false) hash ^= CertSign.GetHashCode();
          if (CrlSign != false) hash ^= CrlSign.GetHashCode();
          if (EncipherOnly != false) hash ^= EncipherOnly.GetHashCode();
          if (DecipherOnly != false) hash ^= DecipherOnly.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (DigitalSignature != false) {
            output.WriteRawTag(8);
            output.WriteBool(DigitalSignature);
          }
          if (ContentCommitment != false) {
            output.WriteRawTag(16);
            output.WriteBool(ContentCommitment);
          }
          if (KeyEncipherment != false) {
            output.WriteRawTag(24);
            output.WriteBool(KeyEncipherment);
          }
          if (DataEncipherment != false) {
            output.WriteRawTag(32);
            output.WriteBool(DataEncipherment);
          }
          if (KeyAgreement != false) {
            output.WriteRawTag(40);
            output.WriteBool(KeyAgreement);
          }
          if (CertSign != false) {
            output.WriteRawTag(48);
            output.WriteBool(CertSign);
          }
          if (CrlSign != false) {
            output.WriteRawTag(56);
            output.WriteBool(CrlSign);
          }
          if (EncipherOnly != false) {
            output.WriteRawTag(64);
            output.WriteBool(EncipherOnly);
          }
          if (DecipherOnly != false) {
            output.WriteRawTag(72);
            output.WriteBool(DecipherOnly);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (DigitalSignature != false) {
            output.WriteRawTag(8);
            output.WriteBool(DigitalSignature);
          }
          if (ContentCommitment != false) {
            output.WriteRawTag(16);
            output.WriteBool(ContentCommitment);
          }
          if (KeyEncipherment != false) {
            output.WriteRawTag(24);
            output.WriteBool(KeyEncipherment);
          }
          if (DataEncipherment != false) {
            output.WriteRawTag(32);
            output.WriteBool(DataEncipherment);
          }
          if (KeyAgreement != false) {
            output.WriteRawTag(40);
            output.WriteBool(KeyAgreement);
          }
          if (CertSign != false) {
            output.WriteRawTag(48);
            output.WriteBool(CertSign);
          }
          if (CrlSign != false) {
            output.WriteRawTag(56);
            output.WriteBool(CrlSign);
          }
          if (EncipherOnly != false) {
            output.WriteRawTag(64);
            output.WriteBool(EncipherOnly);
          }
          if (DecipherOnly != false) {
            output.WriteRawTag(72);
            output.WriteBool(DecipherOnly);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (DigitalSignature != false) {
            size += 1 + 1;
          }
          if (ContentCommitment != false) {
            size += 1 + 1;
          }
          if (KeyEncipherment != false) {
            size += 1 + 1;
          }
          if (DataEncipherment != false) {
            size += 1 + 1;
          }
          if (KeyAgreement != false) {
            size += 1 + 1;
          }
          if (CertSign != false) {
            size += 1 + 1;
          }
          if (CrlSign != false) {
            size += 1 + 1;
          }
          if (EncipherOnly != false) {
            size += 1 + 1;
          }
          if (DecipherOnly != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(KeyUsageOptions other) {
          if (other == null) {
            return;
          }
          if (other.DigitalSignature != false) {
            DigitalSignature = other.DigitalSignature;
          }
          if (other.ContentCommitment != false) {
            ContentCommitment = other.ContentCommitment;
          }
          if (other.KeyEncipherment != false) {
            KeyEncipherment = other.KeyEncipherment;
          }
          if (other.DataEncipherment != false) {
            DataEncipherment = other.DataEncipherment;
          }
          if (other.KeyAgreement != false) {
            KeyAgreement = other.KeyAgreement;
          }
          if (other.CertSign != false) {
            CertSign = other.CertSign;
          }
          if (other.CrlSign != false) {
            CrlSign = other.CrlSign;
          }
          if (other.EncipherOnly != false) {
            EncipherOnly = other.EncipherOnly;
          }
          if (other.DecipherOnly != false) {
            DecipherOnly = other.DecipherOnly;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                DigitalSignature = input.ReadBool();
                break;
              }
              case 16: {
                ContentCommitment = input.ReadBool();
                break;
              }
              case 24: {
                KeyEncipherment = input.ReadBool();
                break;
              }
              case 32: {
                DataEncipherment = input.ReadBool();
                break;
              }
              case 40: {
                KeyAgreement = input.ReadBool();
                break;
              }
              case 48: {
                CertSign = input.ReadBool();
                break;
              }
              case 56: {
                CrlSign = input.ReadBool();
                break;
              }
              case 64: {
                EncipherOnly = input.ReadBool();
                break;
              }
              case 72: {
                DecipherOnly = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                DigitalSignature = input.ReadBool();
                break;
              }
              case 16: {
                ContentCommitment = input.ReadBool();
                break;
              }
              case 24: {
                KeyEncipherment = input.ReadBool();
                break;
              }
              case 32: {
                DataEncipherment = input.ReadBool();
                break;
              }
              case 40: {
                KeyAgreement = input.ReadBool();
                break;
              }
              case 48: {
                CertSign = input.ReadBool();
                break;
              }
              case 56: {
                CrlSign = input.ReadBool();
                break;
              }
              case 64: {
                EncipherOnly = input.ReadBool();
                break;
              }
              case 72: {
                DecipherOnly = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1.KeyUsage.ExtendedKeyUsageOptions] has fields that correspond to
      /// certain common OIDs that could be specified as an extended key usage value.
      /// </summary>
      public sealed partial class ExtendedKeyUsageOptions : pb::IMessage<ExtendedKeyUsageOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ExtendedKeyUsageOptions> _parser = new pb::MessageParser<ExtendedKeyUsageOptions>(() => new ExtendedKeyUsageOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ExtendedKeyUsageOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Security.PrivateCA.V1.KeyUsage.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExtendedKeyUsageOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExtendedKeyUsageOptions(ExtendedKeyUsageOptions other) : this() {
          serverAuth_ = other.serverAuth_;
          clientAuth_ = other.clientAuth_;
          codeSigning_ = other.codeSigning_;
          emailProtection_ = other.emailProtection_;
          timeStamping_ = other.timeStamping_;
          ocspSigning_ = other.ocspSigning_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ExtendedKeyUsageOptions Clone() {
          return new ExtendedKeyUsageOptions(this);
        }

        /// <summary>Field number for the "server_auth" field.</summary>
        public const int ServerAuthFieldNumber = 1;
        private bool serverAuth_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW
        /// server authentication", though regularly used for non-WWW TLS.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ServerAuth {
          get { return serverAuth_; }
          set {
            serverAuth_ = value;
          }
        }

        /// <summary>Field number for the "client_auth" field.</summary>
        public const int ClientAuthFieldNumber = 2;
        private bool clientAuth_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW
        /// client authentication", though regularly used for non-WWW TLS.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ClientAuth {
          get { return clientAuth_; }
          set {
            clientAuth_ = value;
          }
        }

        /// <summary>Field number for the "code_signing" field.</summary>
        public const int CodeSigningFieldNumber = 3;
        private bool codeSigning_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of
        /// downloadable executable code client authentication".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CodeSigning {
          get { return codeSigning_; }
          set {
            codeSigning_ = value;
          }
        }

        /// <summary>Field number for the "email_protection" field.</summary>
        public const int EmailProtectionFieldNumber = 4;
        private bool emailProtection_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email
        /// protection".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool EmailProtection {
          get { return emailProtection_; }
          set {
            emailProtection_ = value;
          }
        }

        /// <summary>Field number for the "time_stamping" field.</summary>
        public const int TimeStampingFieldNumber = 5;
        private bool timeStamping_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding
        /// the hash of an object to a time".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool TimeStamping {
          get { return timeStamping_; }
          set {
            timeStamping_ = value;
          }
        }

        /// <summary>Field number for the "ocsp_signing" field.</summary>
        public const int OcspSigningFieldNumber = 6;
        private bool ocspSigning_;
        /// <summary>
        /// Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing
        /// OCSP responses".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool OcspSigning {
          get { return ocspSigning_; }
          set {
            ocspSigning_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ExtendedKeyUsageOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ExtendedKeyUsageOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ServerAuth != other.ServerAuth) return false;
          if (ClientAuth != other.ClientAuth) return false;
          if (CodeSigning != other.CodeSigning) return false;
          if (EmailProtection != other.EmailProtection) return false;
          if (TimeStamping != other.TimeStamping) return false;
          if (OcspSigning != other.OcspSigning) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ServerAuth != false) hash ^= ServerAuth.GetHashCode();
          if (ClientAuth != false) hash ^= ClientAuth.GetHashCode();
          if (CodeSigning != false) hash ^= CodeSigning.GetHashCode();
          if (EmailProtection != false) hash ^= EmailProtection.GetHashCode();
          if (TimeStamping != false) hash ^= TimeStamping.GetHashCode();
          if (OcspSigning != false) hash ^= OcspSigning.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (ServerAuth != false) {
            output.WriteRawTag(8);
            output.WriteBool(ServerAuth);
          }
          if (ClientAuth != false) {
            output.WriteRawTag(16);
            output.WriteBool(ClientAuth);
          }
          if (CodeSigning != false) {
            output.WriteRawTag(24);
            output.WriteBool(CodeSigning);
          }
          if (EmailProtection != false) {
            output.WriteRawTag(32);
            output.WriteBool(EmailProtection);
          }
          if (TimeStamping != false) {
            output.WriteRawTag(40);
            output.WriteBool(TimeStamping);
          }
          if (OcspSigning != false) {
            output.WriteRawTag(48);
            output.WriteBool(OcspSigning);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (ServerAuth != false) {
            output.WriteRawTag(8);
            output.WriteBool(ServerAuth);
          }
          if (ClientAuth != false) {
            output.WriteRawTag(16);
            output.WriteBool(ClientAuth);
          }
          if (CodeSigning != false) {
            output.WriteRawTag(24);
            output.WriteBool(CodeSigning);
          }
          if (EmailProtection != false) {
            output.WriteRawTag(32);
            output.WriteBool(EmailProtection);
          }
          if (TimeStamping != false) {
            output.WriteRawTag(40);
            output.WriteBool(TimeStamping);
          }
          if (OcspSigning != false) {
            output.WriteRawTag(48);
            output.WriteBool(OcspSigning);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ServerAuth != false) {
            size += 1 + 1;
          }
          if (ClientAuth != false) {
            size += 1 + 1;
          }
          if (CodeSigning != false) {
            size += 1 + 1;
          }
          if (EmailProtection != false) {
            size += 1 + 1;
          }
          if (TimeStamping != false) {
            size += 1 + 1;
          }
          if (OcspSigning != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ExtendedKeyUsageOptions other) {
          if (other == null) {
            return;
          }
          if (other.ServerAuth != false) {
            ServerAuth = other.ServerAuth;
          }
          if (other.ClientAuth != false) {
            ClientAuth = other.ClientAuth;
          }
          if (other.CodeSigning != false) {
            CodeSigning = other.CodeSigning;
          }
          if (other.EmailProtection != false) {
            EmailProtection = other.EmailProtection;
          }
          if (other.TimeStamping != false) {
            TimeStamping = other.TimeStamping;
          }
          if (other.OcspSigning != false) {
            OcspSigning = other.OcspSigning;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                ServerAuth = input.ReadBool();
                break;
              }
              case 16: {
                ClientAuth = input.ReadBool();
                break;
              }
              case 24: {
                CodeSigning = input.ReadBool();
                break;
              }
              case 32: {
                EmailProtection = input.ReadBool();
                break;
              }
              case 40: {
                TimeStamping = input.ReadBool();
                break;
              }
              case 48: {
                OcspSigning = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                ServerAuth = input.ReadBool();
                break;
              }
              case 16: {
                ClientAuth = input.ReadBool();
                break;
              }
              case 24: {
                CodeSigning = input.ReadBool();
                break;
              }
              case 32: {
                EmailProtection = input.ReadBool();
                break;
              }
              case 40: {
                TimeStamping = input.ReadBool();
                break;
              }
              case 48: {
                OcspSigning = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// [Subject][google.cloud.security.privateca.v1.Subject] describes parts of a distinguished name that, in turn,
  /// describes the subject of the certificate.
  /// </summary>
  public sealed partial class Subject : pb::IMessage<Subject>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Subject> _parser = new pb::MessageParser<Subject>(() => new Subject());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Subject> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Subject() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Subject(Subject other) : this() {
      commonName_ = other.commonName_;
      countryCode_ = other.countryCode_;
      organization_ = other.organization_;
      organizationalUnit_ = other.organizationalUnit_;
      locality_ = other.locality_;
      province_ = other.province_;
      streetAddress_ = other.streetAddress_;
      postalCode_ = other.postalCode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Subject Clone() {
      return new Subject(this);
    }

    /// <summary>Field number for the "common_name" field.</summary>
    public const int CommonNameFieldNumber = 1;
    private string commonName_ = "";
    /// <summary>
    /// The "common name" of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CommonName {
      get { return commonName_; }
      set {
        commonName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "country_code" field.</summary>
    public const int CountryCodeFieldNumber = 2;
    private string countryCode_ = "";
    /// <summary>
    /// The country code of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CountryCode {
      get { return countryCode_; }
      set {
        countryCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "organization" field.</summary>
    public const int OrganizationFieldNumber = 3;
    private string organization_ = "";
    /// <summary>
    /// The organization of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Organization {
      get { return organization_; }
      set {
        organization_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "organizational_unit" field.</summary>
    public const int OrganizationalUnitFieldNumber = 4;
    private string organizationalUnit_ = "";
    /// <summary>
    /// The organizational_unit of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OrganizationalUnit {
      get { return organizationalUnit_; }
      set {
        organizationalUnit_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "locality" field.</summary>
    public const int LocalityFieldNumber = 5;
    private string locality_ = "";
    /// <summary>
    /// The locality or city of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Locality {
      get { return locality_; }
      set {
        locality_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "province" field.</summary>
    public const int ProvinceFieldNumber = 6;
    private string province_ = "";
    /// <summary>
    /// The province, territory, or regional state of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Province {
      get { return province_; }
      set {
        province_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "street_address" field.</summary>
    public const int StreetAddressFieldNumber = 7;
    private string streetAddress_ = "";
    /// <summary>
    /// The street address of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StreetAddress {
      get { return streetAddress_; }
      set {
        streetAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "postal_code" field.</summary>
    public const int PostalCodeFieldNumber = 8;
    private string postalCode_ = "";
    /// <summary>
    /// The postal code of the subject.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PostalCode {
      get { return postalCode_; }
      set {
        postalCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Subject);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Subject other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CommonName != other.CommonName) return false;
      if (CountryCode != other.CountryCode) return false;
      if (Organization != other.Organization) return false;
      if (OrganizationalUnit != other.OrganizationalUnit) return false;
      if (Locality != other.Locality) return false;
      if (Province != other.Province) return false;
      if (StreetAddress != other.StreetAddress) return false;
      if (PostalCode != other.PostalCode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CommonName.Length != 0) hash ^= CommonName.GetHashCode();
      if (CountryCode.Length != 0) hash ^= CountryCode.GetHashCode();
      if (Organization.Length != 0) hash ^= Organization.GetHashCode();
      if (OrganizationalUnit.Length != 0) hash ^= OrganizationalUnit.GetHashCode();
      if (Locality.Length != 0) hash ^= Locality.GetHashCode();
      if (Province.Length != 0) hash ^= Province.GetHashCode();
      if (StreetAddress.Length != 0) hash ^= StreetAddress.GetHashCode();
      if (PostalCode.Length != 0) hash ^= PostalCode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (CommonName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CommonName);
      }
      if (CountryCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(CountryCode);
      }
      if (Organization.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Organization);
      }
      if (OrganizationalUnit.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(OrganizationalUnit);
      }
      if (Locality.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Locality);
      }
      if (Province.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Province);
      }
      if (StreetAddress.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(StreetAddress);
      }
      if (PostalCode.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(PostalCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (CommonName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CommonName);
      }
      if (CountryCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(CountryCode);
      }
      if (Organization.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Organization);
      }
      if (OrganizationalUnit.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(OrganizationalUnit);
      }
      if (Locality.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Locality);
      }
      if (Province.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Province);
      }
      if (StreetAddress.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(StreetAddress);
      }
      if (PostalCode.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(PostalCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CommonName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CommonName);
      }
      if (CountryCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CountryCode);
      }
      if (Organization.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Organization);
      }
      if (OrganizationalUnit.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OrganizationalUnit);
      }
      if (Locality.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Locality);
      }
      if (Province.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Province);
      }
      if (StreetAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StreetAddress);
      }
      if (PostalCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PostalCode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Subject other) {
      if (other == null) {
        return;
      }
      if (other.CommonName.Length != 0) {
        CommonName = other.CommonName;
      }
      if (other.CountryCode.Length != 0) {
        CountryCode = other.CountryCode;
      }
      if (other.Organization.Length != 0) {
        Organization = other.Organization;
      }
      if (other.OrganizationalUnit.Length != 0) {
        OrganizationalUnit = other.OrganizationalUnit;
      }
      if (other.Locality.Length != 0) {
        Locality = other.Locality;
      }
      if (other.Province.Length != 0) {
        Province = other.Province;
      }
      if (other.StreetAddress.Length != 0) {
        StreetAddress = other.StreetAddress;
      }
      if (other.PostalCode.Length != 0) {
        PostalCode = other.PostalCode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CommonName = input.ReadString();
            break;
          }
          case 18: {
            CountryCode = input.ReadString();
            break;
          }
          case 26: {
            Organization = input.ReadString();
            break;
          }
          case 34: {
            OrganizationalUnit = input.ReadString();
            break;
          }
          case 42: {
            Locality = input.ReadString();
            break;
          }
          case 50: {
            Province = input.ReadString();
            break;
          }
          case 58: {
            StreetAddress = input.ReadString();
            break;
          }
          case 66: {
            PostalCode = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            CommonName = input.ReadString();
            break;
          }
          case 18: {
            CountryCode = input.ReadString();
            break;
          }
          case 26: {
            Organization = input.ReadString();
            break;
          }
          case 34: {
            OrganizationalUnit = input.ReadString();
            break;
          }
          case 42: {
            Locality = input.ReadString();
            break;
          }
          case 50: {
            Province = input.ReadString();
            break;
          }
          case 58: {
            StreetAddress = input.ReadString();
            break;
          }
          case 66: {
            PostalCode = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] corresponds to a more modern way of listing what
  /// the asserted identity is in a certificate (i.e., compared to the "common
  /// name" in the distinguished name).
  /// </summary>
  public sealed partial class SubjectAltNames : pb::IMessage<SubjectAltNames>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SubjectAltNames> _parser = new pb::MessageParser<SubjectAltNames>(() => new SubjectAltNames());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SubjectAltNames> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubjectAltNames() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubjectAltNames(SubjectAltNames other) : this() {
      dnsNames_ = other.dnsNames_.Clone();
      uris_ = other.uris_.Clone();
      emailAddresses_ = other.emailAddresses_.Clone();
      ipAddresses_ = other.ipAddresses_.Clone();
      customSans_ = other.customSans_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubjectAltNames Clone() {
      return new SubjectAltNames(this);
    }

    /// <summary>Field number for the "dns_names" field.</summary>
    public const int DnsNamesFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_dnsNames_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> dnsNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Contains only valid, fully-qualified host names.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> DnsNames {
      get { return dnsNames_; }
    }

    /// <summary>Field number for the "uris" field.</summary>
    public const int UrisFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_uris_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> uris_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Contains only valid RFC 3986 URIs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Uris {
      get { return uris_; }
    }

    /// <summary>Field number for the "email_addresses" field.</summary>
    public const int EmailAddressesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_emailAddresses_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> emailAddresses_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Contains only valid RFC 2822 E-mail addresses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> EmailAddresses {
      get { return emailAddresses_; }
    }

    /// <summary>Field number for the "ip_addresses" field.</summary>
    public const int IpAddressesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_ipAddresses_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> ipAddresses_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> IpAddresses {
      get { return ipAddresses_; }
    }

    /// <summary>Field number for the "custom_sans" field.</summary>
    public const int CustomSansFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1.X509Extension> _repeated_customSans_codec
        = pb::FieldCodec.ForMessage(42, global::Google.Cloud.Security.PrivateCA.V1.X509Extension.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.X509Extension> customSans_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.X509Extension>();
    /// <summary>
    /// Contains additional subject alternative name values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.X509Extension> CustomSans {
      get { return customSans_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SubjectAltNames);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SubjectAltNames other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dnsNames_.Equals(other.dnsNames_)) return false;
      if(!uris_.Equals(other.uris_)) return false;
      if(!emailAddresses_.Equals(other.emailAddresses_)) return false;
      if(!ipAddresses_.Equals(other.ipAddresses_)) return false;
      if(!customSans_.Equals(other.customSans_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dnsNames_.GetHashCode();
      hash ^= uris_.GetHashCode();
      hash ^= emailAddresses_.GetHashCode();
      hash ^= ipAddresses_.GetHashCode();
      hash ^= customSans_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      dnsNames_.WriteTo(output, _repeated_dnsNames_codec);
      uris_.WriteTo(output, _repeated_uris_codec);
      emailAddresses_.WriteTo(output, _repeated_emailAddresses_codec);
      ipAddresses_.WriteTo(output, _repeated_ipAddresses_codec);
      customSans_.WriteTo(output, _repeated_customSans_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      dnsNames_.WriteTo(ref output, _repeated_dnsNames_codec);
      uris_.WriteTo(ref output, _repeated_uris_codec);
      emailAddresses_.WriteTo(ref output, _repeated_emailAddresses_codec);
      ipAddresses_.WriteTo(ref output, _repeated_ipAddresses_codec);
      customSans_.WriteTo(ref output, _repeated_customSans_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += dnsNames_.CalculateSize(_repeated_dnsNames_codec);
      size += uris_.CalculateSize(_repeated_uris_codec);
      size += emailAddresses_.CalculateSize(_repeated_emailAddresses_codec);
      size += ipAddresses_.CalculateSize(_repeated_ipAddresses_codec);
      size += customSans_.CalculateSize(_repeated_customSans_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SubjectAltNames other) {
      if (other == null) {
        return;
      }
      dnsNames_.Add(other.dnsNames_);
      uris_.Add(other.uris_);
      emailAddresses_.Add(other.emailAddresses_);
      ipAddresses_.Add(other.ipAddresses_);
      customSans_.Add(other.customSans_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dnsNames_.AddEntriesFrom(input, _repeated_dnsNames_codec);
            break;
          }
          case 18: {
            uris_.AddEntriesFrom(input, _repeated_uris_codec);
            break;
          }
          case 26: {
            emailAddresses_.AddEntriesFrom(input, _repeated_emailAddresses_codec);
            break;
          }
          case 34: {
            ipAddresses_.AddEntriesFrom(input, _repeated_ipAddresses_codec);
            break;
          }
          case 42: {
            customSans_.AddEntriesFrom(input, _repeated_customSans_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            dnsNames_.AddEntriesFrom(ref input, _repeated_dnsNames_codec);
            break;
          }
          case 18: {
            uris_.AddEntriesFrom(ref input, _repeated_uris_codec);
            break;
          }
          case 26: {
            emailAddresses_.AddEntriesFrom(ref input, _repeated_emailAddresses_codec);
            break;
          }
          case 34: {
            ipAddresses_.AddEntriesFrom(ref input, _repeated_ipAddresses_codec);
            break;
          }
          case 42: {
            customSans_.AddEntriesFrom(ref input, _repeated_customSans_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes constraints on a [Certificate][google.cloud.security.privateca.v1.Certificate]'s [Subject][google.cloud.security.privateca.v1.Subject] and
  /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames].
  /// </summary>
  public sealed partial class CertificateIdentityConstraints : pb::IMessage<CertificateIdentityConstraints>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateIdentityConstraints> _parser = new pb::MessageParser<CertificateIdentityConstraints>(() => new CertificateIdentityConstraints());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateIdentityConstraints> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateIdentityConstraints() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateIdentityConstraints(CertificateIdentityConstraints other) : this() {
      _hasBits0 = other._hasBits0;
      celExpression_ = other.celExpression_ != null ? other.celExpression_.Clone() : null;
      allowSubjectPassthrough_ = other.allowSubjectPassthrough_;
      allowSubjectAltNamesPassthrough_ = other.allowSubjectAltNamesPassthrough_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateIdentityConstraints Clone() {
      return new CertificateIdentityConstraints(this);
    }

    /// <summary>Field number for the "cel_expression" field.</summary>
    public const int CelExpressionFieldNumber = 1;
    private global::Google.Type.Expr celExpression_;
    /// <summary>
    /// Optional. A CEL expression that may be used to validate the resolved X.509 Subject
    /// and/or Subject Alternative Name before a certificate is signed.
    /// To see the full allowed syntax and some examples, see
    /// https://cloud.google.com/certificate-authority-service/docs/cel-guide
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Type.Expr CelExpression {
      get { return celExpression_; }
      set {
        celExpression_ = value;
      }
    }

    /// <summary>Field number for the "allow_subject_passthrough" field.</summary>
    public const int AllowSubjectPassthroughFieldNumber = 2;
    private bool allowSubjectPassthrough_;
    /// <summary>
    /// Required. If this is true, the [Subject][google.cloud.security.privateca.v1.Subject] field may be copied from a certificate
    /// request into the signed certificate. Otherwise, the requested [Subject][google.cloud.security.privateca.v1.Subject]
    /// will be discarded. The bool is optional to indicate an unset field, which suggests a forgotten value that needs to be set by the caller.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AllowSubjectPassthrough {
      get { if ((_hasBits0 & 1) != 0) { return allowSubjectPassthrough_; } else { return false; } }
      set {
        _hasBits0 |= 1;
        allowSubjectPassthrough_ = value;
      }
    }
    /// <summary>Gets whether the "allow_subject_passthrough" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAllowSubjectPassthrough {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "allow_subject_passthrough" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAllowSubjectPassthrough() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "allow_subject_alt_names_passthrough" field.</summary>
    public const int AllowSubjectAltNamesPassthroughFieldNumber = 3;
    private bool allowSubjectAltNamesPassthrough_;
    /// <summary>
    /// Required. If this is true, the [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] extension may be copied from a
    /// certificate request into the signed certificate. Otherwise, the requested
    /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] will be discarded.
    /// The bool is optional to indicate an unset field, which suggests a forgotten value that needs to be set by the caller.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AllowSubjectAltNamesPassthrough {
      get { if ((_hasBits0 & 2) != 0) { return allowSubjectAltNamesPassthrough_; } else { return false; } }
      set {
        _hasBits0 |= 2;
        allowSubjectAltNamesPassthrough_ = value;
      }
    }
    /// <summary>Gets whether the "allow_subject_alt_names_passthrough" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAllowSubjectAltNamesPassthrough {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "allow_subject_alt_names_passthrough" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAllowSubjectAltNamesPassthrough() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateIdentityConstraints);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateIdentityConstraints other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(CelExpression, other.CelExpression)) return false;
      if (AllowSubjectPassthrough != other.AllowSubjectPassthrough) return false;
      if (AllowSubjectAltNamesPassthrough != other.AllowSubjectAltNamesPassthrough) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (celExpression_ != null) hash ^= CelExpression.GetHashCode();
      if (HasAllowSubjectPassthrough) hash ^= AllowSubjectPassthrough.GetHashCode();
      if (HasAllowSubjectAltNamesPassthrough) hash ^= AllowSubjectAltNamesPassthrough.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (celExpression_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CelExpression);
      }
      if (HasAllowSubjectPassthrough) {
        output.WriteRawTag(16);
        output.WriteBool(AllowSubjectPassthrough);
      }
      if (HasAllowSubjectAltNamesPassthrough) {
        output.WriteRawTag(24);
        output.WriteBool(AllowSubjectAltNamesPassthrough);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (celExpression_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CelExpression);
      }
      if (HasAllowSubjectPassthrough) {
        output.WriteRawTag(16);
        output.WriteBool(AllowSubjectPassthrough);
      }
      if (HasAllowSubjectAltNamesPassthrough) {
        output.WriteRawTag(24);
        output.WriteBool(AllowSubjectAltNamesPassthrough);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (celExpression_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CelExpression);
      }
      if (HasAllowSubjectPassthrough) {
        size += 1 + 1;
      }
      if (HasAllowSubjectAltNamesPassthrough) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateIdentityConstraints other) {
      if (other == null) {
        return;
      }
      if (other.celExpression_ != null) {
        if (celExpression_ == null) {
          CelExpression = new global::Google.Type.Expr();
        }
        CelExpression.MergeFrom(other.CelExpression);
      }
      if (other.HasAllowSubjectPassthrough) {
        AllowSubjectPassthrough = other.AllowSubjectPassthrough;
      }
      if (other.HasAllowSubjectAltNamesPassthrough) {
        AllowSubjectAltNamesPassthrough = other.AllowSubjectAltNamesPassthrough;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (celExpression_ == null) {
              CelExpression = new global::Google.Type.Expr();
            }
            input.ReadMessage(CelExpression);
            break;
          }
          case 16: {
            AllowSubjectPassthrough = input.ReadBool();
            break;
          }
          case 24: {
            AllowSubjectAltNamesPassthrough = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (celExpression_ == null) {
              CelExpression = new global::Google.Type.Expr();
            }
            input.ReadMessage(CelExpression);
            break;
          }
          case 16: {
            AllowSubjectPassthrough = input.ReadBool();
            break;
          }
          case 24: {
            AllowSubjectAltNamesPassthrough = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes a set of X.509 extensions that may be part of some certificate
  /// issuance controls.
  /// </summary>
  public sealed partial class CertificateExtensionConstraints : pb::IMessage<CertificateExtensionConstraints>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateExtensionConstraints> _parser = new pb::MessageParser<CertificateExtensionConstraints>(() => new CertificateExtensionConstraints());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CertificateExtensionConstraints> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Security.PrivateCA.V1.ResourcesReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateExtensionConstraints() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateExtensionConstraints(CertificateExtensionConstraints other) : this() {
      knownExtensions_ = other.knownExtensions_.Clone();
      additionalExtensions_ = other.additionalExtensions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CertificateExtensionConstraints Clone() {
      return new CertificateExtensionConstraints(this);
    }

    /// <summary>Field number for the "known_extensions" field.</summary>
    public const int KnownExtensionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints.Types.KnownCertificateExtension> _repeated_knownExtensions_codec
        = pb::FieldCodec.ForEnum(10, x => (int) x, x => (global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints.Types.KnownCertificateExtension) x);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints.Types.KnownCertificateExtension> knownExtensions_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints.Types.KnownCertificateExtension>();
    /// <summary>
    /// Optional. A set of named X.509 extensions. Will be combined with
    /// [additional_extensions][google.cloud.security.privateca.v1.CertificateExtensionConstraints.additional_extensions] to determine the full set of X.509 extensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.CertificateExtensionConstraints.Types.KnownCertificateExtension> KnownExtensions {
      get { return knownExtensions_; }
    }

    /// <summary>Field number for the "additional_extensions" field.</summary>
    public const int AdditionalExtensionsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Cloud.Security.PrivateCA.V1.ObjectId> _repeated_additionalExtensions_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Cloud.Security.PrivateCA.V1.ObjectId.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.ObjectId> additionalExtensions_ = new pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.ObjectId>();
    /// <summary>
    /// Optional. A set of [ObjectIds][google.cloud.security.privateca.v1.ObjectId] identifying custom X.509 extensions.
    /// Will be combined with [known_extensions][google.cloud.security.privateca.v1.CertificateExtensionConstraints.known_extensions] to determine the full set of
    /// X.509 extensions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Security.PrivateCA.V1.ObjectId> AdditionalExtensions {
      get { return additionalExtensions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CertificateExtensionConstraints);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CertificateExtensionConstraints other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!knownExtensions_.Equals(other.knownExtensions_)) return false;
      if(!additionalExtensions_.Equals(other.additionalExtensions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= knownExtensions_.GetHashCode();
      hash ^= additionalExtensions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      knownExtensions_.WriteTo(output, _repeated_knownExtensions_codec);
      additionalExtensions_.WriteTo(output, _repeated_additionalExtensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      knownExtensions_.WriteTo(ref output, _repeated_knownExtensions_codec);
      additionalExtensions_.WriteTo(ref output, _repeated_additionalExtensions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += knownExtensions_.CalculateSize(_repeated_knownExtensions_codec);
      size += additionalExtensions_.CalculateSize(_repeated_additionalExtensions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CertificateExtensionConstraints other) {
      if (other == null) {
        return;
      }
      knownExtensions_.Add(other.knownExtensions_);
      additionalExtensions_.Add(other.additionalExtensions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            knownExtensions_.AddEntriesFrom(input, _repeated_knownExtensions_codec);
            break;
          }
          case 18: {
            additionalExtensions_.AddEntriesFrom(input, _repeated_additionalExtensions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            knownExtensions_.AddEntriesFrom(ref input, _repeated_knownExtensions_codec);
            break;
          }
          case 18: {
            additionalExtensions_.AddEntriesFrom(ref input, _repeated_additionalExtensions_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateExtensionConstraints message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Describes well-known X.509 extensions that can appear in a [Certificate][google.cloud.security.privateca.v1.Certificate],
      /// not including the [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] extension.
      /// </summary>
      public enum KnownCertificateExtension {
        /// <summary>
        /// Not specified.
        /// </summary>
        [pbr::OriginalName("KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Refers to a certificate's Key Usage extension, as described in [RFC 5280
        /// section 4.2.1.3](https://tools.ietf.org/html/rfc5280#section-4.2.1.3).
        /// This corresponds to the [KeyUsage.base_key_usage][google.cloud.security.privateca.v1.KeyUsage.base_key_usage] field.
        /// </summary>
        [pbr::OriginalName("BASE_KEY_USAGE")] BaseKeyUsage = 1,
        /// <summary>
        /// Refers to a certificate's Extended Key Usage extension, as described in
        /// [RFC 5280
        /// section 4.2.1.12](https://tools.ietf.org/html/rfc5280#section-4.2.1.12).
        /// This corresponds to the [KeyUsage.extended_key_usage][google.cloud.security.privateca.v1.KeyUsage.extended_key_usage] message.
        /// </summary>
        [pbr::OriginalName("EXTENDED_KEY_USAGE")] ExtendedKeyUsage = 2,
        /// <summary>
        /// Refers to a certificate's Basic Constraints extension, as described in
        /// [RFC 5280
        /// section 4.2.1.9](https://tools.ietf.org/html/rfc5280#section-4.2.1.9).
        /// This corresponds to the [X509Parameters.ca_options][google.cloud.security.privateca.v1.X509Parameters.ca_options] field.
        /// </summary>
        [pbr::OriginalName("CA_OPTIONS")] CaOptions = 3,
        /// <summary>
        /// Refers to a certificate's Policy object identifiers, as described in
        /// [RFC 5280
        /// section 4.2.1.4](https://tools.ietf.org/html/rfc5280#section-4.2.1.4).
        /// This corresponds to the [X509Parameters.policy_ids][google.cloud.security.privateca.v1.X509Parameters.policy_ids] field.
        /// </summary>
        [pbr::OriginalName("POLICY_IDS")] PolicyIds = 4,
        /// <summary>
        /// Refers to OCSP servers in a certificate's Authority Information Access
        /// extension, as described in
        /// [RFC 5280
        /// section 4.2.2.1](https://tools.ietf.org/html/rfc5280#section-4.2.2.1),
        /// This corresponds to the [X509Parameters.aia_ocsp_servers][google.cloud.security.privateca.v1.X509Parameters.aia_ocsp_servers] field.
        /// </summary>
        [pbr::OriginalName("AIA_OCSP_SERVERS")] AiaOcspServers = 5,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
